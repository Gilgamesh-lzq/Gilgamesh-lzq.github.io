

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/myfavicon.png">
  <link rel="icon" href="/img/myfavicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#6d472d">
  <meta name="author" content="Gilgamesh">
  <meta name="keywords" content="">
  
    <meta name="description" content="考研408数据结构复习笔记。王道基础班课程，包含一些概念辨析和算法原理以及排序部分的详细代码。红黑树等新增内容、后序总结归纳和错题本会单独写一篇。">
<meta property="og:type" content="article">
<meta property="og:title" content="408-数据结构-基础笔记">
<meta property="og:url" content="https://gilgamesh-lzq.github.io/blog/bb28e6626586/index.html">
<meta property="og:site_name" content="Gilgamesh&#39;s Blog">
<meta property="og:description" content="考研408数据结构复习笔记。王道基础班课程，包含一些概念辨析和算法原理以及排序部分的详细代码。红黑树等新增内容、后序总结归纳和错题本会单独写一篇。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220430095042760.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220430101433521.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220509075336995.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220509081235822.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220509093621103.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511065450396.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511072239815.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511080036870.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511080100377.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511134858301.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511135458505.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511141416286.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511141657545.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511144304140.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511161126503.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220512093700684.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220513074609640.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220513075119292.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220513080431846.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220513103438081.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514075145374.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514075224620.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514075526287.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514080201344.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514090720648.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514100149104.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514110801329.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514213057304.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514112353943.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514113028116.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514113321970.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220516091342672.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220516101117829.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220516103431004.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220516104917292.png">
<meta property="article:published_time" content="2022-05-16T03:18:01.000Z">
<meta property="article:modified_time" content="2022-05-16T03:29:00.259Z">
<meta property="article:author" content="Gilgamesh">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220430095042760.png">
  
  
  <title>408-数据结构-基础笔记 - Gilgamesh&#39;s Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hint.css@2/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10/styles/xcode.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/fluid-extension.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"gilgamesh-lzq.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":85,"cursorChar":"_","loop":true},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Gilgamesh&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    
                    ===所有分类===
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/">
                    <i class="iconfont icon-brush"></i>
                     知识积累
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/">
                    <i class="iconfont icon-bookmark"></i>
                     课程作业
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E6%9D%82%E8%B0%88/">
                    <i class="iconfont icon-bug"></i>
                     杂谈
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E8%80%83%E7%A0%94/">
                    <i class="iconfont icon-books"></i>
                     考研
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                作者
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:04:03-00:40:56-home.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="408-数据结构-基础笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-05-16 11:18" pubdate>
        2022年5月16日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.7k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      61 分钟
    </span>
  

  
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">408-数据结构-基础笔记</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年5月16日 上午
                
              </p>
            
            <div class="markdown-body">
              <h1 align="center">408-数据结构-基础笔记</h1>

<p><br></p>
<h2 id="1-顺序表"><a href="#1-顺序表" class="headerlink" title="1.顺序表"></a>1.顺序表</h2><ul>
<li>单链表某节点前插入数据时，可以后插然后交换数据位置，实现O(1)。删除同理</li>
</ul>
<h2 id="2-栈和队列"><a href="#2-栈和队列" class="headerlink" title="2.栈和队列"></a>2.栈和队列</h2><h3 id="2-1-基础知识"><a href="#2-1-基础知识" class="headerlink" title="2.1.基础知识"></a>2.1.基础知识</h3><ul>
<li><p><strong>判断合法出栈顺序</strong>：如果入栈为1234…，那么出栈时对于任意数字，排在它后面比它小的必然是倒序。</p>
<ul>
<li>如果入栈不是按大小排列，那么用序号判断。一回事。</li>
<li>所有合法总数为卡塔兰数：$\frac{1}{n+1}C_{2n}^n$</li>
</ul>
</li>
<li>链栈的物理实现：头插头删的单链表</li>
<li>循环队列不能填满，需要空一个位置来判满（与指针重合时的队空区别开）<ul>
<li>如果不允许浪费，那么元数据添加一个size表示目前数据元素个数；或者一个tag表示最近操作是插入还是删除</li>
</ul>
</li>
<li><p>双端队列：两边可输入输出。还分为输入受限和输出受限</p>
<ul>
<li>合法顺序：在栈中不合法的组合中挑一些变为合法<ul>
<li>输入受限：先把第一个数前面的数全画好再判断</li>
<li>输出受限：先分析第一个数前面的数应该如何输入</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-括号匹配问题"><a href="#2-2-括号匹配问题" class="headerlink" title="2.2.括号匹配问题"></a>2.2.括号匹配问题</h3><ul>
<li>遍历所有字符，左括号入栈，右括号弹栈匹配</li>
<li>左括号单身：全走完了栈不空</li>
<li>右括号单身：匹配时栈空</li>
<li>左右不匹配</li>
<li><p>表达式求值 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220430095042760.png" srcset="/img/loading.gif" lazyload alt="image-20220430095042760" style="zoom:25%;" /></p>
<ul>
<li>后缀<ul>
<li>中缀转后缀<ul>
<li>后缀表达式中运算符顺序就是计算生效顺序</li>
<li><strong>机算结果左优先</strong>：只要有更靠近左边的运算符可以计算，那么就算左边的</li>
<li><img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220430101433521.png" srcset="/img/loading.gif" lazyload alt="image-20220430101433521" style="zoom:30%;" /></li>
</ul>
</li>
<li>后缀求值：从左往右扫描，有运算符就让它前面两个操作数运算</li>
</ul>
</li>
<li>前缀<ul>
<li>中缀转前缀<ul>
<li><strong>右优先</strong>，排列顺序就是计算顺序</li>
</ul>
</li>
<li>前缀求值：从右往左入栈</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="2-3-特殊矩阵压缩存储"><a href="#2-3-特殊矩阵压缩存储" class="headerlink" title="2.3.特殊矩阵压缩存储"></a>2.3.特殊矩阵压缩存储</h3><ul>
<li>通常行列号下标从1开始，要注意</li>
<li><p>对称阵：储存对角线和下三角部分，共$1+2+…+n=\frac{n\cdot(n+1)}{2}$个元素，如果按行优先存储的话：</p>
<ul>
<li>在最后元素数组下标为$\frac{n\cdot(n+1)}{2}-1$</li>
<li>下标映射公式为$k=\frac{i\cdot(i-1)}{2}+j-1，(i\ge j)；a_{ij}=a_{ji}，(i&lt;j)$</li>
</ul>
</li>
<li><p>上三角：前面有1～n-1行，元素下标为$[n+(n-1)+…+(n-i+2)]+(j-i)$ </p>
</li>
<li>三对角 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220509075336995.png" srcset="/img/loading.gif" lazyload alt="image-20220509075336995" style="zoom:30%;" /></li>
<li>稀疏矩阵 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220509081235822.png" srcset="/img/loading.gif" lazyload alt="image-20220509081235822" style="zoom:30%;" /></li>
</ul>
<h2 id="3-串"><a href="#3-串" class="headerlink" title="3.串"></a>3.串</h2><ul>
<li><p>描述位置一般从1开始</p>
</li>
<li><p>子串：串中任意个连续字符</p>
</li>
<li><p>朴素模式匹配：失败情况下：最坏o(mn)，最好o(n)</p>
</li>
<li><p>KMP算法：用一个next数组储存模式串本身的特征，某位置不匹配时i不变，j应该变为的值。避免了回溯过程</p>
<ul>
<li><p>复杂度o(n) <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220509093621103.png" srcset="/img/loading.gif" lazyload alt="image-20220509093621103" style="zoom:30%;" /></p>
</li>
<li><p>复杂度o(m) $\begin{cases}next[1],无脑写0\\next[2],无脑写1\\i位置左侧画一条分界线，模式串右移，匹配时候j是多少\end{cases}$</p>
</li>
<li><p>nextval求法：在next数组基础上计算</p>
<blockquote>
<p>1.第一位的nextval值必定为0，第二位如果于第一位相同则为0，如果不同则为1。  </p>
<p>2.第三位的next值为1，那么将第三位和第一位进行比较，均为a，相同，则，第三位的nextval值为0。</p>
<p>3.第四位的next值为2，那么将第四位和第二位进行比较，不同，则第四位的nextval值为其next值，为2。</p>
<p>4.第五位的next值为2，那么将第五位和第二位进行比较，相同，第二位的next值为1，则继续将第二位与第一位进行比较，不同，则第五位的nextval值为第二位的next值，为1。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h2 id="4-树"><a href="#4-树" class="headerlink" title="4.树"></a>4.树</h2><h3 id="4-1-概念性质"><a href="#4-1-概念性质" class="headerlink" title="4.1.概念性质"></a>4.1.概念性质</h3><ul>
<li><p>树的度：度的最大值</p>
</li>
<li><p>深度：默认从1开始</p>
</li>
<li><p>性质：</p>
<ul>
<li><p>节点数=总度数+1</p>
</li>
<li><p>度为0的点比度为2的点多一个</p>
<blockquote>
<p>$n=n_0+n_1+n_2$</p>
<p>$n=n_1+2n_2+1$ 作差</p>
</blockquote>
</li>
<li><p>度为m的树第i层最多有$m^{i-1}$个节点</p>
</li>
<li><p>高度为h的m叉树最多$\frac{m^h-1}{m-1}$个节点（等比数列求和），度为m的树至少有h+m-1个节点</p>
</li>
<li><p>具有n个节点的m叉树的最小高度为$log_m(n(m-1)+1)$   </p>
<blockquote>
<p>$\frac{m^{h-1}-1}{m-1}&lt;n\le\frac{m^h-1}{m-1}$ 比上一层多，不能超过这一层</p>
<p>$m^{h-1}&lt;n(m-1)+1\le m^h$</p>
</blockquote>
</li>
</ul>
</li>
<li><p>特殊的二叉树</p>
<ul>
<li>满二叉树：按层序从1开始编号，节点为i的左孩子为2i，右孩子为2i+1</li>
<li>完全二叉树：编号能和满二叉树一一对应<ul>
<li>n个节点的完全二叉树高度h为 $log_2(n+1)$</li>
<li>单分支节点只能有0或1个，双分支节点有奇数个</li>
<li>$n_0=n_2+1$，已知总数可以推出$n_0\ n_1\ n_2$</li>
</ul>
</li>
<li>平衡二叉树：树上任一结点的左右子树深度之差不超过1</li>
</ul>
</li>
</ul>
<h3 id="4-2-存储结构"><a href="#4-2-存储结构" class="headerlink" title="4.2.存储结构"></a>4.2.存储结构</h3><ul>
<li>顺序存储： 节点编号从1开始，数组0位置空着 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511065450396.png" srcset="/img/loading.gif" lazyload alt="image-20220511065450396" style="zoom:40%;" /></li>
<li>链式存储： 三叉链表：多一个父指针</li>
<li><strong>求深度</strong> <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511072239815.png" srcset="/img/loading.gif" lazyload alt="image-20220511072239815" style="zoom:30%;" /></li>
<li>层序遍历：辅助队列，广搜。入队的是指针不是值，这样省地方</li>
</ul>
<h3 id="4-3-线索二叉树"><a href="#4-3-线索二叉树" class="headerlink" title="4.3.线索二叉树"></a>4.3.线索二叉树</h3><ul>
<li><p><img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511080036870.png" srcset="/img/loading.gif" lazyload alt="image-20220511080036870" style="zoom:30%;" /> <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511080100377.png" srcset="/img/loading.gif" lazyload alt="image-20220511080100377" style="zoom:30%;" /></p>
<blockquote>
<p>中序线索化 </p>
</blockquote>
</li>
<li><p>最后一个节点需要特殊处理右线索，让它为空</p>
</li>
<li><p><strong>先序线索化</strong>遍历时需要判断<strong>左孩子</strong>tag是否为0</p>
</li>
<li><p><strong>后序线索化</strong>遍历时需要判断<strong>右孩子</strong>tag是否为0</p>
</li>
<li><p>找前驱后继：</p>
<ul>
<li><p>中序：后继：右子树的左下角节点<strong>；</strong>前驱：左子树右下角节点</p>
</li>
<li><p>先序：后继：左右孩子<strong>；</strong>前驱：找不到</p>
</li>
<li><p><img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511134858301.png" srcset="/img/loading.gif" lazyload alt="image-20220511134858301" style="zoom:30%;" /></p>
<blockquote>
<p>最后一个遍历的就是右边路走到头、然后左边路走到头这样的最后一个</p>
</blockquote>
</li>
<li><p>后序：前驱：右左孩子<strong>；</strong>后驱：找不到</p>
</li>
<li><p><img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511135458505.png" srcset="/img/loading.gif" lazyload alt="image-20220511135458505" style="zoom:30%;" /></p>
<blockquote>
<p>最后一个遍历的就是左边路走到头、然后右边路走到头这样的最后一个</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="4-4-普通的树"><a href="#4-4-普通的树" class="headerlink" title="4.4.普通的树"></a>4.4.普通的树</h3><ul>
<li>双亲表示法：找双亲方便，找孩子不方便（节点中储存双亲的下标）</li>
<li>孩子表示法：找孩子方便，找双亲不方便 （节点中储存孩子链表头指针）</li>
<li>孩子兄弟表示法也就是树和二叉树的转化<img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511141416286.png" srcset="/img/loading.gif" lazyload alt="image-20220511141416286" style="zoom:20%;" /></li>
<li>森林和二叉树转化 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511141657545.png" srcset="/img/loading.gif" lazyload alt="image-20220511141657545" style="zoom:20%;" /></li>
<li><img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511144304140.png" srcset="/img/loading.gif" lazyload alt="image-20220511144304140" style="zoom:37%;" /></li>
</ul>
<h3 id="4-5-平衡二叉树"><a href="#4-5-平衡二叉树" class="headerlink" title="4.5.平衡二叉树"></a>4.5.平衡二叉树</h3><ul>
<li>二叉排序树BST<ul>
<li>插入时如果元素已经存在则应当<strong>插入失败</strong></li>
<li>删除时可以用直接前驱（左子树最小的）或者直接后继（右子树最大的）来替代</li>
</ul>
</li>
<li><p>平衡二叉树AVL</p>
<ul>
<li>$\ $ <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220511161126503.png" srcset="/img/loading.gif" lazyload alt="image-20220511161126503" style="zoom:40%;" /></li>
<li>用$n_h$表示深度为h的平衡树中含有的最少节点数，则有$n_0=0,n_1=1,n_2=2$，且<strong>$n_h=n_{h-1}+n_{h-2}+1$</strong>。含n个节点的平衡二叉树最大深度为$log_2n$</li>
</ul>
</li>
<li><p>哈夫曼树</p>
<ul>
<li>构造：每次挑权值最小的两个节点组合成树，根节点权值为他们的和</li>
<li>前缀编码：任何一个字符的编码都不是另一个编码的前缀</li>
</ul>
</li>
</ul>
<h2 id="5-图"><a href="#5-图" class="headerlink" title="5.图"></a>5.图</h2><h3 id="5-1-概念"><a href="#5-1-概念" class="headerlink" title="5.1.概念"></a>5.1.概念</h3><ul>
<li>图的顶点集一定是非空集，但是边集可以是空集</li>
<li>对于n个顶点的无向图G，若G是连通图，则最少有n-1条边；若G是非连通图，则最多可能有$C_{n-1}^2$条边</li>
<li>有向图强连通最少边数就是一个回路，即n条边</li>
<li>生成子图：顶点一样，边可以少一点</li>
<li>无向图中的<strong>极大连通子图</strong>称为<strong>连通分量</strong>；有向图中的<strong>极大连通子图</strong>称为<strong>强连通分量</strong>（有来无回不是连通）</li>
<li>联通图的生成树：顶点全有，边尽可能少</li>
<li><u>边 &lt; 顶点 log 顶点</u> 一般认为是稀疏图，但不绝对</li>
<li>有向树：从根向叶子有向的树</li>
</ul>
<h3 id="5-2-存储结构"><a href="#5-2-存储结构" class="headerlink" title="5.2.存储结构"></a>5.2.存储结构</h3><ul>
<li>邻接矩阵：$A^n[i][j]$表示从i到j边长为n的路径数目</li>
<li>邻接表：<img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220512093700684.png" srcset="/img/loading.gif" lazyload alt="image-20220512093700684" style="zoom:25%;" /></li>
<li>十字链表-有向图<img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220513074609640.png" srcset="/img/loading.gif" lazyload alt="image-20220513074609640" style="zoom:30%;" /></li>
<li>邻接多重表-无向图<img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220513075119292.png" srcset="/img/loading.gif" lazyload alt="image-20220513075119292" style="zoom:30%;" /></li>
<li>对比<img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220513080431846.png" srcset="/img/loading.gif" lazyload alt="image-20220513080431846" style="zoom:35%;" /></li>
</ul>
<h3 id="5-3-经典应用"><a href="#5-3-经典应用" class="headerlink" title="5.3.经典应用"></a>5.3.经典应用</h3><ul>
<li><p>广搜</p>
<ul>
<li>复杂度：邻接矩阵0(n)，邻接表o(m+n)</li>
<li>邻接表表示不唯一，因此它的广度优先生成树也不唯一</li>
</ul>
</li>
<li><p>深搜</p>
<ul>
<li>最坏空间复杂度：调用栈深度o(n)</li>
<li>时间复杂度：邻接矩阵$o(n^2)$，邻接表o(m+n)</li>
</ul>
</li>
<li><p>最小生成树</p>
<ul>
<li><p>Prim算法：从一个顶点开始构建；将代价最小的新顶点纳入，直到所有顶点都纳入为止</p>
<blockquote>
<p>复杂度只和点有关，$o(n^2)$，适合<strong>边稠密图</strong></p>
</blockquote>
</li>
<li><p>Kruskal算法：选择权值最小的边，使这条边的两头连通（原本已经连通的就不选），直到所有结点都连通</p>
<blockquote>
<p>复杂度只和边有关，$o(m\cdot log_2m)$，适合<strong>边稀疏图</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>最短路径</p>
<ul>
<li><p>无权图直接用广度优先</p>
</li>
<li><p>Dijkstra <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220513103438081.png" srcset="/img/loading.gif" lazyload alt="image-20220513103438081" style="zoom:25%;" /> 每一轮遍历两遍，共n-1轮，时间复杂度$o(n^2)$</p>
</li>
<li><p>Floyd <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514075145374.png" srcset="/img/loading.gif" lazyload alt="image-20220514075145374" style="zoom:40%;" /> <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514075224620.png" srcset="/img/loading.gif" lazyload alt="image-20220514075224620" style="zoom:30%;" /></p>
<blockquote>
<p>代码 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514075526287.png" srcset="/img/loading.gif" lazyload alt="image-20220514075526287" style="zoom:30%;" /> <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514080201344.png" srcset="/img/loading.gif" lazyload alt="image-20220514080201344" style="zoom:25%;" /></p>
<p>可以解决负权值，但不能有负权回路，因为可能没有最短路径</p>
</blockquote>
</li>
</ul>
</li>
<li><p>有向无环图<strong>DAG</strong> </p>
<ul>
<li>描述表达式：给运算符编号，分层写</li>
<li>拓扑排序<strong>AOV</strong>：输出入度为0的点，把它们发出的边删除。重复<ul>
<li>邻接表：边和点都要遍历一次，o(m+n)</li>
<li>邻接矩阵：扫描整个表，$o(n^2)$</li>
</ul>
</li>
<li>逆拓扑排序：输出出度为0的点，把指向它们的边删除。重复<ul>
<li>邻接表效率低，需要逆邻接表。或者邻接矩阵</li>
<li>可以使用DFS递归实现 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514090720648.png" srcset="/img/loading.gif" lazyload alt="image-20220514090720648" style="zoom:35%;" /></li>
</ul>
</li>
<li>关键路径<strong>AOE</strong>：<ul>
<li>仅有一个开始顶点（源点）和一个结束顶点（汇点）</li>
<li>源点到汇点所有路径中<strong>最长的</strong>是关键路径</li>
<li>时间余量：某个活动最短开始时间和最长开始时间的差值</li>
<li>步骤：确定点的拓扑排序时间（取大）；确定点的逆拓扑排序时间（取小）；确定边的开始时间；确定边的结束时间；时间余量为0的是关键活动，它们组成关键路径</li>
<li>可能有多条关键路径，只提高一条关腿路径上的关健活动速度并不能缩短整个工程的工期，只有加快那些包括在所有关键路径上的关键活动才能达到缩短工期的目的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-查找"><a href="#6-查找" class="headerlink" title="6.查找"></a>6.查找</h2><ul>
<li>关键字：不重复的唯一标识</li>
<li>平均查找长度ASL，通常考虑成功失败两种情况</li>
</ul>
<h3 id="6-1-折半查找"><a href="#6-1-折半查找" class="headerlink" title="6.1.折半查找"></a>6.1.折半查找</h3><ul>
<li>代码 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514100149104.png" srcset="/img/loading.gif" lazyload alt="image-20220514100149104" style="zoom:40%;" /></li>
<li>查找判定树：如果是偶数个元素，那么右边比左边多一个</li>
<li>树高 $log_2(n+1)$，只有最下面一层可以不满</li>
<li>n个数，失败节点n+1个</li>
<li><strong>不是一定比顺序查找快</strong></li>
</ul>
<h3 id="6-2-分块查找"><a href="#6-2-分块查找" class="headerlink" title="6.2.分块查找"></a>6.2.分块查找</h3><ul>
<li><p>若索引表中不包含目标关键字，则折半查找索引表最终停在Iow&gt;high，要在low所指分块中查找</p>
<blockquote>
<p>原因：最终Iow左边一定小于目标关键字，high右边一定大于目标关键字。而分块存储的索引表中保存的是各个分块的最大关键字</p>
</blockquote>
</li>
<li><p>Iow超出索引表范围，查找失败</p>
</li>
<li><p>复杂度</p>
<blockquote>
<p>假设，长度为的查找表被均匀地分为b块，每块s个元素。</p>
<p>顺序查找：$ASL=\frac{b+1}{2}+\frac{s+1}{2}=\frac{s^2+2s+n}{2s}$。$s=\sqrt{n}$时，$ASL_{min}=\sqrt{n}+1$ </p>
<p>折半查找：$ASL=log_2(b+1)+\frac{s+1}{2}$ </p>
</blockquote>
</li>
</ul>
<h3 id="6-3-B-树"><a href="#6-3-B-树" class="headerlink" title="6.3.B+树"></a>6.3.B+树</h3><ul>
<li>非叶根节点至少两颗子树，其他每个分支节点至少$\lceil\frac{m}{2}\rceil$颗子树</li>
<li>每个分支节点最多m颗子树</li>
<li>节点储存分支中最大值</li>
<li>节点子树个数 和 关键字个数 相等</li>
<li>示意图 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514110801329.png" srcset="/img/loading.gif" lazyload alt="image-20220514110801329" style="zoom:30%;" /></li>
</ul>
<h3 id="6-4-B树"><a href="#6-4-B树" class="headerlink" title="6.4.B树"></a>6.4.B树</h3><ul>
<li><p>含n个关键字的<strong><u>m阶B树</u></strong></p>
<blockquote>
<p><strong>最小高度</strong>：<u>让每个结点尽可能的满</u>，有m-1个关键字，m个分叉，则有$n\le(m-1)(1+m+m^2+…+m^{h-1})=m^h-1$，故$h\ge log_m(n+1)$ </p>
<p><strong>最大高度</strong>：<u>让各层的分叉尽可能的少</u>，即根节点只有2个分叉，其他结点只有$\lceil\frac{m}{2}\rceil$个分叉。</p>
<p>各层结点至少有：第一层1、第二层2、第三层$\lceil\frac{m}{2}\rceil$…第h层$2\lceil\frac{m}{2}\rceil^{h-2}$，第h+1层共有叶子节点$2\lceil\frac{m}{2}\rceil^{h-1}$个。</p>
<p>n个关键字的B树必有n+1个叶子节点（失败空指针），则$n+1\ge 2\lceil\frac{m}{2}\rceil^{h-1}$，即$h\le log_{\lceil\frac{m}{2}\rceil}\frac{n+1}{2}+1$ </p>
</blockquote>
</li>
<li><p>含n个关键字的<strong><u>m叉B树</u></strong></p>
<blockquote>
<p><strong>最大高度</strong>：让每个结点包含的关键字、分叉尽可能的少。记$k=\lceil\frac{m}{2}\rceil$</p>
<p>递推 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514213057304.png" srcset="/img/loading.gif" lazyload alt="image-20220514213057304" style="zoom:50%;" /></p>
<p>h层的m阶B树至少包含关键字总数 $1+2(k-1)(k^0+k^1+…+k^{h-2})=1+2(k^{h-1}-1)\le n$</p>
<p>得到 $h\le log_{\lceil\frac{m}{2}\rceil}\frac{n+1}{2}+1$ </p>
</blockquote>
</li>
<li><p>B树的插入 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514112353943.png" srcset="/img/loading.gif" lazyload alt="image-20220514112353943" style="zoom:25%;" /></p>
<blockquote>
<p>保证上层节点比它左边节点的子节点的最大值大。一旦超出了阶数就取$\lceil\frac{m}{2}\rceil$节点到上层分裂</p>
</blockquote>
</li>
<li><p>B树的删除 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514113028116.png" srcset="/img/loading.gif" lazyload alt="image-20220514113028116" style="zoom:20%;" /> <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220514113321970.png" srcset="/img/loading.gif" lazyload alt="image-20220514113321970" style="zoom:20%;" /></p>
<blockquote>
<p><strong>删根节点</strong>：找到直接前驱（左子树中最下层最右边）或后继（右子树最下层最左边）顶替</p>
<p><strong>兄弟够借</strong>：后继 和 后继的后继 来填补；前驱 和 前驱的前驱 来填补</p>
<p><strong>兄弟不够借</strong>：被删除关键字所在结点删除前的关键字个数低于下限，且此时与该结点相邻的左、右兄弟结点的关键字个数均=$\lceil\frac{m}{2}\rceil-1$，则将关键字删除后与左（或右）兄弟结点及双亲结点中的关键字进行合并</p>
</blockquote>
</li>
</ul>
<h3 id="6-5-散列查找"><a href="#6-5-散列查找" class="headerlink" title="6.5.散列查找"></a>6.5.散列查找</h3><ul>
<li><p>装填因子$\alpha=$表中记录个数/散列表表长</p>
</li>
<li><p>查找效率：取决于散列函数、处理冲突的方法、装填因子</p>
</li>
<li><p>散列函数</p>
<ul>
<li>取余法：一般取素数</li>
<li>线性变化或直接定址：适用于关键字分布基本连续</li>
<li>数字分析法：截取数字的一部分作为散列地址，比如手机号</li>
<li>平方取中：取平方值的中间几位。这种方法得到的<strong>散列地址与关键字的每位都有关系</strong>，因此使得散列地址<strong>分布比较均匀</strong>，适用于关键字的<strong>每位取值都不够均匀</strong>或均<strong>小于散列地址所需的位数</strong>。</li>
</ul>
</li>
<li><p>处理冲突</p>
<ul>
<li><p>拉链法</p>
</li>
<li><p>开放定址法：</p>
<ul>
<li><p>线性探测：看后面一个位置</p>
<blockquote>
<p>删除时使用一个删除标记，而不是直接置空。否则可能导致后面删除时查找失败</p>
</blockquote>
</li>
<li><p>平方探测：$\pm k^2$。散列表长度m必须是一个可以表示成4j+3的素数，才能探测到所有位置</p>
</li>
<li><p>伪随机序列</p>
</li>
</ul>
</li>
<li><p>再散列法</p>
</li>
</ul>
</li>
</ul>
<h2 id="7-排序"><a href="#7-排序" class="headerlink" title="7.排序"></a>7.排序</h2><h3 id="7-1-插入排序"><a href="#7-1-插入排序" class="headerlink" title="7.1.插入排序"></a>7.1.插入排序</h3><ul>
<li>空间复杂度o(1)</li>
<li>最好时间复杂度o(n)，比较n-1次，不需要移动</li>
<li>最坏时间复杂度$o(n^2)$ </li>
<li>平均时间复杂度$o(n^2)$ </li>
<li><strong>稳定排序</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//插入排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j, temp;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">1</span>; i &lt; n; i++)<br>        <span class="hljs-keyword">if</span>(A[i] &lt; A[i<span class="hljs-number">-1</span>])<br>        &#123;<br>            temp = A[i];<br>            <span class="hljs-keyword">for</span>(j = i<span class="hljs-number">-1</span>; j &gt;= <span class="hljs-number">0</span> &amp;&amp; A[j] &gt; temp; --j)<br>                A[j+<span class="hljs-number">1</span>] = A[j];<br>            A[j+<span class="hljs-number">1</span>] = temp<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用折半查找来加速。当Iow&gt;high时折半查找停止，应将[low,i-1]内的元素全部右移，并将A[0]复制到Iow所指位置。比较次数减少，移动次数不变。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//折半插入排序。使用了哨兵</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">InsertSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[],<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j, low, mid, high;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">2</span>; i &lt;= n; i++)<br>    &#123;<br>        A[<span class="hljs-number">0</span>] = A[i];<br>        low = <span class="hljs-number">1</span>; high = i<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(low &lt;= high)<br>        &#123;<br>            mid = (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span>(A[mid] &gt; A[<span class="hljs-number">0</span>]) <br>                high = mid<span class="hljs-number">-1</span>;<br>            <span class="hljs-keyword">else</span> <br>                low = mid+<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span>(j = i<span class="hljs-number">-1</span>; j &gt;= high+<span class="hljs-number">1</span>; --j)<br>            A[j+<span class="hljs-number">1</span>] = A[j];<br>        A[j+<span class="hljs-number">1</span>] = A[<span class="hljs-number">0</span>];<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure>
<p>对链表插入排序，比较$o(n^2)$，移动只需要改几个指针。</p>
<h3 id="7-2-希尔排序"><a href="#7-2-希尔排序" class="headerlink" title="7.2.希尔排序"></a>7.2.希尔排序</h3><ul>
<li>按间隔d划分为子表，使用插入排序。然后缩小d继续，直到d=1</li>
<li>空间复杂度o(1)</li>
<li>最坏时间复杂度为$o(n^2)$，当n在某个范围内时，可达$o(n^{1.3})$ </li>
<li><strong>不稳定排序</strong></li>
<li>需要随机访问，只能顺序表，不能链表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//希尔排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ShellSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> d, i, j;<br>    <span class="hljs-keyword">for</span>(d = n/<span class="hljs-number">2</span>; d &gt; <span class="hljs-number">1</span>; d = d/<span class="hljs-number">2</span>) <span class="hljs-comment">//步长变化</span><br>        <span class="hljs-keyword">for</span>(i = d+<span class="hljs-number">1</span>; i &lt;= n; ++i)<br>            <span class="hljs-keyword">if</span>(A[i] &lt; A[i-d])<br>            &#123;<br>                A[<span class="hljs-number">0</span>] = A[i]; <span class="hljs-comment">//用于暂存，不是哨兵</span><br>                <span class="hljs-keyword">for</span>(j = i-d; j &gt; <span class="hljs-number">0</span> &amp;&amp; A[<span class="hljs-number">0</span>] &lt; A[j]; j -= d)<br>                    A[j+d] = A[j];<br>                A[j+d] = A[<span class="hljs-number">0</span>];<br>            &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-3-冒泡排序"><a href="#7-3-冒泡排序" class="headerlink" title="7.3.冒泡排序"></a>7.3.冒泡排序</h3><ul>
<li>空间复杂度o(1)</li>
<li>最好时间复杂度o(n)，比较n-1次，不需要移动</li>
<li>最坏时间复杂度$\frac{n(n-1)}{2}$，等于比较次数和交换次数</li>
<li><strong>稳定排序</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//冒泡排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++)<br>    &#123;<br>        <span class="hljs-type">bool</span> flag = flase;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = n<span class="hljs-number">-1</span>; j &gt; i; j--)<br>            <span class="hljs-keyword">if</span>(A[j<span class="hljs-number">-1</span>] &gt; A[j])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(A[j<span class="hljs-number">-1</span>], A[j])<br>                    flag = <span class="hljs-literal">true</span>;<br>            &#125;<br>        <span class="hljs-keyword">if</span>(flag == flase) <span class="hljs-keyword">return</span>; <span class="hljs-comment">//本趟遍历后没有发生交换，说明表已经有序</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-4-快排"><a href="#7-4-快排" class="headerlink" title="7.4.快排"></a>7.4.快排</h3><ul>
<li>最好时间复杂度$o(nlog_2n)$<ul>
<li>最坏时间复杂度$o(n^2)$</li>
</ul>
</li>
<li>最好空间复杂度$o(log_2n)$<ul>
<li>最坏空间复杂度$o(n)$</li>
</ul>
</li>
<li><strong>不稳定排序</strong></li>
<li>优化：<ul>
<li>选头中尾，取中间值作为枢轴</li>
<li>随机选枢轴</li>
</ul>
</li>
<li>定义辨析：一趟排序，对所有数据进行一次处理，相当于快排处理一层。可以一次确定多个元素的位置</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//快速排序</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pivot = A[low]; <span class="hljs-comment">//第一个元素作为枢轴</span><br>    <span class="hljs-keyword">while</span>(low &lt; high)<br>    &#123;<br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; A[high] &gt;= pivot) --high;<br>        A[low] = A[high];<br>        <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; A[low] &lt;= pivot) ++low;<br>        A[high] = A[low];<br>    &#125;<br>    A[low] = pivot; <span class="hljs-comment">//枢轴元素放到最终位置</span><br>    <span class="hljs-keyword">return</span> low; <span class="hljs-comment">//返回存放枢轴元素的位置</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QuickSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (low &lt; high) <span class="hljs-comment">//递归跳出条件</span><br>    &#123;<br>        <span class="hljs-type">int</span> pivotpos = <span class="hljs-built_in">Partition</span>(A, low, high); <span class="hljs-comment">//划分</span><br>        <span class="hljs-built_in">QuickSort</span>(A, low, pivotpos<span class="hljs-number">-1</span>);<br>        <span class="hljs-built_in">QuickSort</span>(A, pivotpos+<span class="hljs-number">1</span>, high);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-5-简单选择排序"><a href="#7-5-简单选择排序" class="headerlink" title="7.5.简单选择排序"></a>7.5.简单选择排序</h3><ul>
<li>空间复杂度$o(1)$</li>
<li>时间复杂度$o(n^2)$，需要对比$\frac{n(n-1)}{2}$次</li>
<li><strong>不稳定排序</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//选择排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SelectSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n<span class="hljs-number">-1</span>; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> min = i;<br>        <span class="hljs-keyword">for</span>(nt j = i+<span class="hljs-number">1</span>; j &lt; n; j++)<br>            <span class="hljs-keyword">if</span>(A[j] &lt; A[min]) <br>                min = j;<br>        <span class="hljs-keyword">if</span>(min != i) <br>            <span class="hljs-built_in">swap</span>(A[i],A[min]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-6-堆排序"><a href="#7-6-堆排序" class="headerlink" title="7.6.堆排序"></a>7.6.堆排序</h3><ul>
<li>调整方法：检查当前结点是否根比左、右都大。若不满足，将当前结点与更大的一个孩子互换</li>
<li>构建大根堆，把堆顶和堆底元素换，然后继续维护堆</li>
<li>建堆的时间不超过4n，复杂度o(n)</li>
<li>排序过程每一趟复杂度不超过o(h)，即$o(log_2n)$。共n-1趟，故$o(nlog_2n)$</li>
<li>空间o(1)</li>
<li><strong>不稳定排序</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//堆排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">BuildMaxHeap</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len/<span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--) <span class="hljs-comment">//从后往前调整所有非终端节点</span><br>        <span class="hljs-built_in">HeapAdjust</span>(A, i, len);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> k, <span class="hljs-type">int</span> len)</span> <span class="hljs-comment">//调整以k为根的子树</span></span><br><span class="hljs-function"></span>&#123;<br>    A[<span class="hljs-number">0</span>] = A[k]; <span class="hljs-comment">//暂存根节点</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>*k, i &lt;= len; i *= <span class="hljs-number">2</span>) <span class="hljs-comment">//沿key较大的子结点向下筛选</span><br>    &#123;<br>        <span class="hljs-keyword">if</span>(i &lt; len &amp;&amp; A[i] &lt; A[i+<span class="hljs-number">1</span>])<br>            i++; <span class="hljs-comment">//取key较大的子结点的下标</span><br>        <span class="hljs-keyword">if</span>(A[<span class="hljs-number">0</span>] &gt;= A[i]) <br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">//筛选结束</span><br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            A[k] = A[i]; <span class="hljs-comment">//将A[i]调整到双亲结点上</span><br>            k = i; <span class="hljs-comment">//继续向下筛选</span><br>        &#125;<br>    &#125;<br>    A[k] = A[<span class="hljs-number">0</span>]; <span class="hljs-comment">//被筛选结点的值放入最终位置</span><br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">BuildMaxHeap</span>(A, len);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = len; i &gt; <span class="hljs-number">1</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(A[i], A[i]);<br>        <span class="hljs-built_in">HeapAdjust</span>(A, <span class="hljs-number">1</span>, i<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>小根堆<ul>
<li>插入：新元素加入堆底，然后一路和父亲比大小，一路上升直到无法继续为止</li>
<li>删除：删除它，把堆底放上来，不断下坠</li>
</ul>
</li>
</ul>
<h3 id="7-7-归并排序"><a href="#7-7-归并排序" class="headerlink" title="7.7.归并排序"></a>7.7.归并排序</h3><ul>
<li>2路归并：两个指针依次比较后移，更小的放到新数组里。一个序列空了之后另一个序列剩下的直接整个复制进来。</li>
<li>示意图 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220516091342672.png" srcset="/img/loading.gif" lazyload alt="image-20220516091342672" style="zoom:25%;" /></li>
<li>时间复杂度$o(nlog_2n)$。n个元素进行2路归并，共$\lceil\frac{m}{2}\rceil$趟，每一趟n个数都处理一遍</li>
<li>空间复杂度o(n)</li>
<li><strong>稳定排序</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//归并排序</span><br><span class="hljs-type">int</span> *B = (<span class="hljs-type">int</span>*)<span class="hljs-built_in">malloc</span>(n * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">//辅助数组</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> mid, <span class="hljs-type">int</span> high)</span> <span class="hljs-comment">//mid左右两个数组各自有序</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j, k;<br>    <span class="hljs-keyword">for</span>(k = low; k &lt;= high; k++)<br>        B[k] = A[k]; <span class="hljs-comment">//将A中所有元素复制到B中</span><br>    <span class="hljs-keyword">for</span>(i = low,j = mid+<span class="hljs-number">1</span>,k = i; i &lt;= mid &amp;&amp; i &lt;= high; k++)<br>    &#123;<br>        <span class="hljs-keyword">if</span>(B[i] &lt;= B[j])<br>            A[k] = B[i++]; <span class="hljs-comment">//将较小值复制到A中</span><br>        <span class="hljs-keyword">else</span><br>            A[k] = B[j++];<br>    &#125;<br>    <span class="hljs-keyword">while</span>(i &lt;= mid)<br>        A[k++] = B[i++];<br>    <span class="hljs-keyword">while</span>(j &lt;= high)<br>        A[k++] = B[j++];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergeSort</span><span class="hljs-params">(<span class="hljs-type">int</span> A[], <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span>(low &lt; high)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>; <span class="hljs-comment">//划分</span><br>        <span class="hljs-built_in">MergeSort</span>(A, low, mid); <span class="hljs-comment">//左半部分归并</span><br>        <span class="hljs-built_in">MergeSort</span>(A, mid+<span class="hljs-number">1</span>, high); <span class="hljs-comment">//右半部分归并</span><br>        <span class="hljs-built_in">Merge</span>(A, low, mid, high); <span class="hljs-comment">//归并</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-8-基数排序"><a href="#7-8-基数排序" class="headerlink" title="7.8.基数排序"></a>7.8.基数排序</h3><ul>
<li>按照每一位数字取值范围划分几个不同的队伍，按位数从低到高划分队伍后用链表接起来，重复</li>
<li>r个辅助队列（关键字的范围），n个元素，d趟分配（关键字划分几部分）<ul>
<li>空间复杂度o(r)</li>
<li>时间复杂度o(d(n+r))。一趟分配o(n)，一趟收集o(r)，总共d趟分配、收集</li>
</ul>
</li>
<li><strong>稳定排序</strong></li>
<li>擅长的问题：<ul>
<li>数据元素的关键字可以方便地拆分为不太多的组（d）：<del>给5个人的身份证号排序</del></li>
<li>每组关键字的取值范围不大（r）：<del>给中文人名排序</del></li>
<li>数据元素较多（n）：给十亿人的身份证号排序</li>
</ul>
</li>
</ul>
<h3 id="7-9-外部排序"><a href="#7-9-外部排序" class="headerlink" title="7.9.外部排序"></a>7.9.外部排序</h3><ul>
<li><p>2路归并：每次归并合并两个归并段。输入缓冲区空了马上用归并段没读如的部分补上。以此类推直到合并为一个归并段</p>
</li>
<li><p>示意图 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220516101117829.png" srcset="/img/loading.gif" lazyload alt="image-20220516101117829" style="zoom:25%;" /></p>
</li>
<li><p>r个归并段，k路归并，归并趟数$=\lceil log_kr\rceil$。使用多路归并，减少初始归并段数量，减少磁盘IO，加速排序</p>
<ul>
<li>k路归并，得到一个最小值需要k-1次对比</li>
</ul>
</li>
<li><p>定义：<strong>k路平衡归并</strong>：</p>
<ul>
<li>最多只能有k个段归并为一个</li>
<li>每一趟归并中，若有m个归并段参与归并，则经过这一趟处理得到$\lceil\frac{m}{k}\rceil$个新的归并段</li>
</ul>
</li>
<li><p>改进：败者树</p>
<ul>
<li>结构 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220516103431004.png" srcset="/img/loading.gif" lazyload alt="image-20220516103431004" style="zoom:30%;" /></li>
<li>新补上的元素沿着上一次胜者的路径比较即可</li>
<li>k路归并，第一次需要对比关键字k-1次，接下来只需要$\lceil log_2k\rceil$次</li>
</ul>
</li>
<li><p>改进：置换-选择排序</p>
<ul>
<li>记录上一次输出的最小值，要是补进来的比它还小就不动，直到整个内存工作区中的数都比上一次输出的最小值小</li>
<li>结构 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:05:16-11:15:56-image-20220516104917292.png" srcset="/img/loading.gif" lazyload alt="image-20220516104917292" style="zoom:25%;" /></li>
<li>使用置换-选择排序，可以让每个初始归并段的长度超越内存工作区大小的限制</li>
</ul>
</li>
<li><p>改进：最佳归并树</p>
<ul>
<li><p>磁盘IO次数等于归并树的带权路径长度乘二</p>
</li>
<li><p>2路归并：按照初始归并段的长度，构造哈夫曼树</p>
</li>
<li><p>多路归并：类似于哈夫曼树，每次选最小的k个子树。<strong>需要提前补0</strong></p>
<blockquote>
<p>$\begin{cases}n=n_0+n_k\\k\cdot n_k=n-1\end{cases}\Longrightarrow n_0=(k-1)n_k+1\Longrightarrow n_k=\frac{(n_0-1)}{(k-1)}$ </p>
<p>初始归并段数量+补0数量 刚好能除尽 k-1</p>
<p>(初始数量-1) % （k-1）= u，需要补充 (k-1)-u 个0</p>
</blockquote>
</li>
</ul>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%80%83%E7%A0%94/">考研</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外均为原创，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/a7a8bae9a7ba/">
                        <span class="hidden-mobile">使用wget爬取整个网站</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    

  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        沪ICP证2022011890号
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js" ></script>
  






  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          load: ['ui/lazy']
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
