

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=light>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/myfavicon.png">
  <link rel="icon" href="/img/myfavicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#6d472d">
  <meta name="author" content="Gilgamesh">
  <meta name="keywords" content="">
  
    <meta name="description" content="计算机考研408操作系统科目基础复习笔记，包含基础的概念辨析、流程图、对比表格等等。图片和知识点基于王道基础班。仅供学习交流，请勿用于商业用途。">
<meta property="og:type" content="article">
<meta property="og:title" content="408-操作系统-基础笔记">
<meta property="og:url" content="https://gilgamesh-lzq.github.io/blog/edf4f8bf2394/index.html">
<meta property="og:site_name" content="Gilgamesh&#39;s Blog">
<meta property="og:description" content="计算机考研408操作系统科目基础复习笔记，包含基础的概念辨析、流程图、对比表格等等。图片和知识点基于王道基础班。仅供学习交流，请勿用于商业用途。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220702200347438.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220702213837931.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220703094049910.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220703093829731.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220703221832653.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220704234134429.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220705013052706.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220705140133827.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220705143409645.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220705143702378.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220705193654256.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708095847201.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708102626448.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708150345084.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708151511014.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708152745909.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708225322327.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220710143640788.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220710161813080.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220710190653753.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220710193018586.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220711144249529.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220711160920617.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220712014849661.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220712015829973.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220712231307737.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220713065355694.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220713071726194.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220713094119330.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714092009949.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714092212003.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714092405728.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714094211540.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714095441427.png">
<meta property="og:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714095658350.png">
<meta property="article:published_time" content="2022-04-03T08:09:09.000Z">
<meta property="article:modified_time" content="2022-07-23T04:52:41.474Z">
<meta property="article:author" content="Gilgamesh">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220702200347438.png">
  
  
  <title>408-操作系统-基础笔记 - Gilgamesh&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://lib.baomitu.com/highlight.js/10.7.3/styles/xcode.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/fluid-extension.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"gilgamesh-lzq.github.io","root":"/","version":"1.8.14","typing":{"enable":true,"typeSpeed":90,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":2},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.1.0"></head>


<body>
  <header style="height: 80vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Gilgamesh&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" href="javascript:;" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    
                    ===所有分类===
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E7%9F%A5%E8%AF%86%E7%A7%AF%E7%B4%AF/">
                    <i class="iconfont icon-brush"></i>
                     知识积累
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/">
                    <i class="iconfont icon-bookmark"></i>
                     课程作业
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E6%9D%82%E8%B0%88/">
                    <i class="iconfont icon-bug"></i>
                     杂谈
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/%E8%80%83%E7%A0%94/">
                    <i class="iconfont icon-books"></i>
                     考研
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                文章
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                作者
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:04:03-00:40:56-home.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="408-操作系统-基础笔记">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-04-03 16:09" pubdate>
        2022年4月3日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      14k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      87 分钟
    </span>
  

  
  
</div>

            
          </div>

          
            <div class="scroll-down-bar">
              <i class="iconfont icon-arrowdown"></i>
            </div>
          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">408-操作系统-基础笔记</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年7月23日 下午
                
              </p>
            
            <div class="markdown-body">
              <h1 align="center">408-操作系统-基础笔记</h1>

<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><ul>
<li>管理<strong>系统资源</strong><ul>
<li>功能：处理机管理、存储器管理、文件管理、设备管理</li>
<li>目标：安全、高效</li>
</ul>
</li>
<li>向上层提供服务<ul>
<li>命令接口<ul>
<li>联机（交互式）：command</li>
<li>脱机：批处理</li>
<li>狭义的定义中，<strong>不包含GUI</strong></li>
</ul>
</li>
<li>程序接口：系统调用（又称为 广义指令）</li>
</ul>
</li>
</ul>
<h3 id="1-1-四个特征"><a href="#1-1-四个特征" class="headerlink" title="1.1.四个特征"></a>1.1.四个特征</h3><blockquote>
<p>并发和共享是两个最基本特征，二者互为存在条件</p>
</blockquote>
<ul>
<li><p>并发</p>
<ul>
<li><p>宏观上同时，微观上交替</p>
<blockquote>
<p>并行：同时发生</p>
</blockquote>
</li>
</ul>
</li>
<li><p>共享：系统中的资源可供内存中多个并发执行的进程共同使用</p>
<ul>
<li><p>互斥共享：在一个时间段内，这个资源只允许一个进程来使用</p>
</li>
<li><p>同时共享：在一个时间段内，允许多个的进程同时对它进行访问</p>
<blockquote>
<p>所谓「同时」是宏观上的</p>
</blockquote>
</li>
</ul>
</li>
<li><p>虚拟：没有并发性那虚拟性就没有存在的意义</p>
<ul>
<li>空分复用：如虚拟存储</li>
<li>时分复用：如虚拟处理器</li>
</ul>
</li>
<li><p>异步：进程的执行走走停停，以不可预知的进度前进。有了并发性才有异步性</p>
</li>
</ul>
<h3 id="1-2-发展和分类"><a href="#1-2-发展和分类" class="headerlink" title="1.2.发展和分类"></a>1.2.发展和分类</h3><ul>
<li>手工操作系统</li>
<li>批处理系统<ul>
<li>单道批处理系统：引入<strong>脱机输入/输出</strong>技术（外围机+磁带），并由<strong>监督程序</strong>负责控制作业的输入、输出</li>
<li>多道批处理系统（操作系统开始出现）<ul>
<li>资源利用率大幅提升</li>
<li>响应时间长，不能人机交互</li>
</ul>
</li>
</ul>
</li>
<li>分时操作系统：计算机以<strong>时间片</strong>为单位<strong>轮流</strong>为各个用户/作业服务，各个用户可通过终端与计算机进行<strong>交互</strong><ul>
<li>解决了人机交互</li>
<li>感受不到别人的存在</li>
<li>完全公平，不区分紧急性</li>
</ul>
</li>
<li>实时操作系统：<strong>及时性，可靠性</strong><ul>
<li>硬实时 系统：必须在绝对严格的规定时间内完成处理，如导弹、自动驾驶</li>
<li>软实时系统：能接受偶尔违反时间规定</li>
</ul>
</li>
<li><del>网络操作系统</del></li>
<li><del>分布式操作系统</del></li>
<li><del>个人计算机操作系统</del></li>
</ul>
<h3 id="1-3-基本原理"><a href="#1-3-基本原理" class="headerlink" title="1.3.基本原理"></a>1.3.基本原理</h3><ul>
<li><p>运行机制</p>
<ul>
<li>两种指令<ul>
<li>特权：只有内核程序可以使用</li>
<li>非特权</li>
</ul>
</li>
<li>两种处理器状态<ul>
<li>核心态（管态）-&gt;用户态：一条特权指令，修改PSW中的状态字，意味着让出使用权</li>
<li>用户态（目态）-&gt;核心态：中断</li>
</ul>
</li>
<li>两种程序<ul>
<li>内核程序</li>
<li>应用程序</li>
</ul>
</li>
</ul>
</li>
<li><p>中断和异常</p>
<ul>
<li>中断作用<ul>
<li>“中断”是让<strong>操作系统内核夺回CPU使用权的唯一途径</strong></li>
<li>没有中断技术就没办法实现多道程序并发</li>
</ul>
</li>
<li>类型<ul>
<li>内中断（异常）：和当前执行指令有关<ul>
<li>陷入 trap：陷入指令，系统调用</li>
<li>故障 fault：错误条件引发，可以修复。如<strong>缺页</strong></li>
<li>终止 abort：致命错误引发，无法修复。如<strong>除0、非法使用特权指令</strong></li>
</ul>
</li>
<li>外中断：和当前执行指令无关<ul>
<li>时钟</li>
<li>IO设备</li>
</ul>
</li>
</ul>
</li>
<li>中断机制的原理<ul>
<li>检查时间<ul>
<li>内中断：执行指令时会检查是否有异常发生</li>
<li>外中断：每个指令周期末尾，CPU都会检查是否有外中断信号需要处理</li>
</ul>
</li>
<li>查询<strong>中断向量表</strong>，找到对应的处理程序</li>
</ul>
</li>
</ul>
</li>
<li><p>系统调用</p>
<blockquote>
<p>凡是与<strong>共享资源</strong>有关的操作（如存储分配、/O操作、文件管理等），都必须通过<strong>系统调用</strong>的方式向操作系统内核提出服务请求，由操作系统<strong>内核代为完成</strong>。这样可以保证系统的<strong>稳定性和安全性</strong>，防止用户进行非法操作</p>
</blockquote>
<ul>
<li>设备管理：完成 设备 的请求/释放/启动 等</li>
<li>文件管理：完成 文件 的读/写/创建/删除 等</li>
<li>进程控制：完成 进程 的创建/撤销/阻塞/唤醒 等</li>
<li>进程通信：完成 进程 之间的消息传递/信号传递 等 </li>
<li><p>内存管理：完成 内存 的分配/回收 等</p>
<blockquote>
<p><strong>陷入指令</strong>是在<strong>用户态</strong>执行的，执行陷入指令（访管指令）之后立即引发一个<strong>内中断</strong>，使CPU进入<strong>核心态</strong><br><strong>发出系统调用</strong>请求是在用户态，而对<strong>系统调用的相应处理</strong>在<strong>核心态</strong>下进行</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="1-4-体系结构"><a href="#1-4-体系结构" class="headerlink" title="1.4.体系结构"></a>1.4.体系结构</h3><ul>
<li>内核结构 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220702200347438.png" srcset="/img/loading.gif" lazyload alt="image-20220702200347438" style="zoom:50%;" /></li>
<li>微内核：频繁转换用户态和内核态，影响性能</li>
</ul>
<h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2.进程"></a>2.进程</h2><h3 id="2-1-进程"><a href="#2-1-进程" class="headerlink" title="2.1.进程"></a>2.1.进程</h3><h4 id="2-1-1-概念"><a href="#2-1-1-概念" class="headerlink" title="2.1.1.概念"></a>2.1.1.概念</h4><ul>
<li>程序：<strong>静态的</strong>，存放在磁盘里的可执行文件，指令的集合</li>
<li>进程：<strong>动态的</strong>，程序的一次执行过程<ul>
<li>进程实体：PCB+程序段+数据段</li>
<li><strong>进程</strong>是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配</strong>和<strong>调度</strong>的一个独立单位</li>
</ul>
</li>
<li>PCB：是进程存在的唯一标志</li>
</ul>
<h4 id="2-1-2-特征"><a href="#2-1-2-特征" class="headerlink" title="2.1.2.特征"></a>2.1.2.特征</h4><ul>
<li>动态性：进程是程序的一次执行过程，进程的<strong>最基本特性</strong></li>
<li>并发性：内存中有多个进程实体，各进程可并发执行</li>
<li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位</li>
<li>异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制“来解决异步问题</li>
<li>结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li>
</ul>
<h4 id="2-1-3-状态"><a href="#2-1-3-状态" class="headerlink" title="2.1.3.状态"></a>2.1.3.状态</h4><p><img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220702213837931.png" srcset="/img/loading.gif" lazyload alt="image-20220702213837931" style="zoom:40%;" /></p>
<ul>
<li>创建：分配空间，初始化PCB</li>
<li>就绪</li>
<li>运行</li>
<li>阻塞：主动地等待某个事件</li>
<li><p>终止：CPU做善后，回收资源</p>
</li>
<li><p>组织方式</p>
<ul>
<li>链式：运行、就绪各有一个指针，指向一个队列，高优先级放在队头。阻塞由于原因不同可以有多个指针</li>
<li>索引表：就绪和阻塞各有一个索引表，表项是指向一个个进程的指针</li>
</ul>
</li>
</ul>
<h4 id="2-1-4-进程控制"><a href="#2-1-4-进程控制" class="headerlink" title="2.1.4.进程控制"></a>2.1.4.进程控制</h4><p>创建、销毁、状态转换</p>
<ul>
<li>创建原语：申请空白PCB，分配资源，初始化PCB，PCB插入就绪队列<ul>
<li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li>
<li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程</li>
<li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li>
<li>应用请求：由用户进程主动请求创建一个子进程</li>
</ul>
</li>
<li>撤销原语：找到PCB，[剥夺CPU]，终止所有子进程、资源归还父进程或操作系统、删除PCB<ul>
<li>正常结束：exit调用</li>
<li>异常结束：被强行杀掉</li>
<li>外界干预：用户选择杀掉进程</li>
</ul>
</li>
<li>阻塞原语：找到PCB，保护进程运行现场，将PCB状态信息设置为“阻塞态”，将PCB插入<strong>相应事件</strong>的等待队列<ul>
<li>需要等待分配资源</li>
<li>需要等待其他进程</li>
</ul>
</li>
<li>唤醒原语：找到PCB，从等待队列移除，设置进程为就绪态，PCB插入就绪队列<ul>
<li>等待的事件发生</li>
</ul>
</li>
<li>切换原语：运行环境存入PCB，PCB移入相应队列，选择另一个程序并更新PCB，根据PCB恢复所需的运行环境<ul>
<li>当前进程时间片到</li>
<li>有更高优先级的进程到达</li>
<li>当前进程主动阻塞</li>
<li>当前进程终止</li>
</ul>
</li>
</ul>
<h4 id="2-1-5-进程通信"><a href="#2-1-5-进程通信" class="headerlink" title="2.1.5.进程通信"></a>2.1.5.进程通信</h4><ul>
<li><p>共享存储：对其的访问应当是<strong>互斥的</strong>，自己负责实现 </p>
<blockquote>
<p>只需要加一个段表或页表 </p>
</blockquote>
<ul>
<li>基于数据结构：可以理解为「特殊的全局变量」。灵活性差、速度慢</li>
<li>基于存储区</li>
</ul>
</li>
<li><p>消息传递：消息头包含发送pid、接收pid、消息长度等格式化信息</p>
<ul>
<li>直接通信：直接指明接受消息的pid，接收也需要指明是谁发的 </li>
<li>间接通信：发送方完善消息体，然后指明发送给哪个信箱 ；接收方指明从哪个信箱中接收数据 </li>
</ul>
</li>
<li><p>管道通信：pipe文件（内存中开辟大小固定的缓冲区（循环队列）），FIFO</p>
<blockquote>
<p>两个方向的管道互斥，由操作系统保证</p>
<p>管道写满了，写数据的进程会阻塞， 直到管道里有空位了</p>
<p>管道空，读进程阻塞，直到管道里有数据了</p>
<p> 一旦读出，数据彻底消失。408真题考过<strong>多写1读</strong>（实际上linux可以多写多读）</p>
</blockquote>
</li>
</ul>
<h4 id="2-1-6-线程"><a href="#2-1-6-线程" class="headerlink" title="2.1.6.线程"></a>2.1.6.线程</h4><ul>
<li>特点<ul>
<li>在引入线程之后，进程只作为除  CPU 之外的系统资源的分配单元。线程变为调度的基本单位</li>
<li>同一进程的不同线程间共享进程的资源</li>
</ul>
</li>
<li>实现方式<ul>
<li>用户级线程：通过线程库实现逻辑线程。一个线程被阻塞，整个进程被阻塞</li>
<li>内核级线程：并行能力强，可在多核处理机上并行执行。<strong>需要CPU状态切换</strong></li>
</ul>
</li>
<li>多线程模型<ul>
<li>一对一：退化为内核级线程，管理成本高</li>
<li>多对一：退化为用户级线程，只有一个CPU，并行度不高</li>
<li>多对多：克服了两种缺点</li>
</ul>
</li>
</ul>
<h3 id="2-2-处理机调度"><a href="#2-2-处理机调度" class="headerlink" title="2.2.处理机调度"></a>2.2.处理机调度</h3><h4 id="2-2-1-概念"><a href="#2-2-1-概念" class="headerlink" title="2.2.1.概念"></a>2.2.1.概念</h4><ul>
<li><p>三个层次 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220703094049910.png" srcset="/img/loading.gif" lazyload alt="image-20220703094049910" style="zoom:50%;" /></p>
<ul>
<li><p>高级调度（作业调度）</p>
<ul>
<li><p>每个作业<strong>只调入一次，调出一次</strong>。作业调入时会建立PCB，调出时才撤销PCB</p>
<blockquote>
<p>作业：一个具体的任务</p>
<p>用户向系统提交一个作业 == 用户让操作系统启动一个程序（来处理一个具体的任务）</p>
</blockquote>
</li>
</ul>
</li>
<li><p>中级调度（内存调度）：</p>
<ul>
<li>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被挂起的进程PCB会被组织成<strong>挂起队列</strong></li>
</ul>
</li>
<li><p>低级调度（进程调度）：<strong>最基本的调度</strong></p>
</li>
</ul>
</li>
<li><p>七状态模型 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220703093829731.png" srcset="/img/loading.gif" lazyload alt="image-20220703093829731" style="zoom:40%;" /></p>
</li>
<li><p>时机</p>
<ul>
<li><p>需要进程调度</p>
<ul>
<li>主动放弃：正常终止、发生异常、主动请求阻塞</li>
<li>被动放弃：时间片用完、中断、更高优先级的进程进入就绪队列</li>
</ul>
</li>
<li><p>不能进程调度</p>
<blockquote>
<p>进程在<strong>操作系统内核程序临界区</strong>中<strong>不能</strong>进行调度与切换  ✅</p>
<p>临界区有 普通 和 操作系统临界区 的区别，操作系统临界区管理进程调度队列等数据结构</p>
</blockquote>
<ul>
<li>中断过程中</li>
<li>操作系统内核程序临界区中</li>
<li>原语（原子操作）</li>
</ul>
</li>
</ul>
</li>
<li><p>切换与过程</p>
<blockquote>
<p><strong>狭义的进程调度</strong>指的是从就绪队列中选中一个要运行的进程</p>
<p><strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程</p>
<p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤</p>
</blockquote>
<ul>
<li>进程切换的过程：保存PCB，恢复另一个进程的PCB</li>
</ul>
</li>
<li><p>方式</p>
<ul>
<li>非抢占式</li>
<li>抢占式</li>
</ul>
</li>
</ul>
<h4 id="2-2-2-评价指标"><a href="#2-2-2-评价指标" class="headerlink" title="2.2.2.评价指标"></a>2.2.2.评价指标</h4><ul>
<li>CPU利用率：CPU“忙碌”的时间占总时间的比例</li>
<li>系统吞吐量：单位时间内完成作业的数量</li>
<li>周转时间<ul>
<li><u>周转时间：完成时间 - 提交时间</u></li>
<li>平均周转时间：各作业周转时间之和 / 作业数</li>
<li><u>带权周转时间：周转时间 / 实际运行时间</u>  $\ge 1$</li>
<li>平均带权周转时间：各作业带权周转时间之和 / 作业数</li>
</ul>
</li>
<li>等待时间<ul>
<li>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间</li>
<li>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间</strong>，还要加上<strong>作业在外存后备队列中等待的时间</strong>。</li>
</ul>
</li>
<li>响应时间：从用户<strong>提交请求</strong>到<strong>首次响应</strong>所用的时间</li>
</ul>
<h4 id="2-2-3-调度算法"><a href="#2-2-3-调度算法" class="headerlink" title="2.2.3.调度算法"></a>2.2.3.调度算法</h4><ul>
<li><p>先来先服务</p>
<ul>
<li>非抢占</li>
<li>长作业有利，短作业不利</li>
<li>不会导致饥饿</li>
</ul>
</li>
<li><p>最短作业优先</p>
<blockquote>
<p>“抢占式的短作业/进程优先调度算法的平均等待时间、平均周转时间最少”</p>
<p>“所有进程几乎同时到达时，采用SJF调度算法的平均等待时间、平均周转时间最少”</p>
</blockquote>
<ul>
<li>没有特别说明一般是指 <strong>非抢占式</strong></li>
<li>抢占式版本：<strong>最短剩余时间优先</strong>。时间点：就绪队列改变、一个进程完成</li>
<li>短作业有利，长作业不利</li>
<li>会导致饥饿</li>
</ul>
</li>
<li><p>最高响应比优先</p>
<ul>
<li>响应比 = （等待时间 + 要求服务时间）/ 要求服务时间    $\ge 1$</li>
<li>非抢占</li>
<li>不会导致饥饿</li>
</ul>
</li>
<li><p>时间片轮转</p>
<blockquote>
<p>进程下处理机瞬间有进程到达，一般认为到达的排在前面</p>
</blockquote>
<ul>
<li>抢占式</li>
<li>时间片太大，退化为先来先服务。响应变慢</li>
<li>时间片太小，切换太频繁</li>
<li>一般来说，设计时间片时要让切换进程的开销占比不超过$1\%$</li>
<li>公平，响应快，适合分时操作系统</li>
</ul>
</li>
<li><p>优先级调度：选择高优先级的</p>
<blockquote>
<p>例题：<img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220703221832653.png" srcset="/img/loading.gif" lazyload alt="image-20220703221832653" style="zoom:50%;" /> 关注答题模式</p>
</blockquote>
<ul>
<li>抢占式和非抢占式都有</li>
<li>优先数和优先级的关系不一定，看题目</li>
<li><blockquote>
<p>系统进程优先级高</p>
<p>前台进程优先级高</p>
<p>操作系统偏好IO型进程，因为可以让IO设备尽早投入工作，资源利用率高</p>
</blockquote>
</li>
</ul>
</li>
<li><p>多级反馈队列</p>
<blockquote>
<p>高级队列先运行，运行一个时间片就把进程放到下一级队列的队尾</p>
<p>只有高级队列空了，它的下一级队列才能开始执行</p>
<p>被抢占剥夺处理器的进程放到此队列的队尾而不是下一级队列</p>
</blockquote>
<ul>
<li>新到达进程快速得到响应</li>
<li>短进程使用较少时间即可完成</li>
<li>不必估计运行时间</li>
<li>灵活调整对各类型进程的偏好程度 </li>
</ul>
</li>
</ul>
<h3 id="2-3-同步和互斥"><a href="#2-3-同步和互斥" class="headerlink" title="2.3.同步和互斥"></a>2.3.同步和互斥</h3><h4 id="2-3-1-进程互斥"><a href="#2-3-1-进程互斥" class="headerlink" title="2.3.1.进程互斥"></a>2.3.1.进程互斥</h4><ul>
<li>对临界资源的互斥访问，在逻辑上分：<ul>
<li>进入区：判断能否访问临界资源</li>
<li>临界区：访问临界资源的代码</li>
<li>退出区：解除「正在访问临界资源」标志</li>
<li>剩余区</li>
</ul>
</li>
<li>原则：有限等待，让权等待</li>
<li>软件实现<ul>
<li>单标志法：访问完临界区后把权限交给另一个进程，即进程进入临界区的权限只能由另一个进程赋予。「谦让」</li>
<li>双标志先检查：数组记录各进程进入临界区的意愿<ul>
<li>每一个进程在进入临界区之前，都会先检查对方是否想进入临界区</li>
<li>如果对方不想进入临界区，表达自己想要进入临界区</li>
<li><strong>违反忙则等待原则</strong></li>
<li>问题的关键在于<strong>检查和上所这两个动作并不能一气呵成</strong></li>
</ul>
</li>
<li>双标志后检查<ul>
<li>先上锁，后检查</li>
<li><strong>违反空闲让进、有限等待原则</strong></li>
</ul>
</li>
<li>Peterson算法<ul>
<li>把自己的数组记录改为True</li>
<li>把Turn改为对方，表示可以让对方先使用</li>
<li>如果对方想用，或者最后一次是我谦让了，那就等待</li>
<li><strong>违反让权等待原则</strong>：如果不能进入临界区就应当放弃CPU</li>
</ul>
</li>
</ul>
</li>
<li>硬件实现<ul>
<li>中断屏蔽方法<ul>
<li>不适用于多处理机</li>
<li>权限特别大，只适用于内核进程</li>
</ul>
</li>
<li>TestAndSet（TS指令/TSL指令）<ul>
<li>适用于多处理机环境</li>
<li>一边上锁一边检查，硬件实现</li>
</ul>
</li>
<li>Swap指令（XCHG指令）<img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220704234134429.png" srcset="/img/loading.gif" lazyload alt="image-20220704234134429" style="zoom:60%;" /></li>
</ul>
</li>
</ul>
<h4 id="2-3-2-信号量"><a href="#2-3-2-信号量" class="headerlink" title="2.3.2.信号量"></a>2.3.2.信号量</h4><ul>
<li><p>整型信号量</p>
<ul>
<li><p>用一个变量来表示某种资源的数量</p>
</li>
<li><p>不满足让权等待，会发生<strong>忙等</strong>（while死循环，不让出CPU）</p>
</li>
</ul>
</li>
<li><p>记录型信号量</p>
<ul>
<li>用一个结构体记录资源数量和等待队列</li>
<li>wait：资源数 -1 ，如果 &lt;0，那么阻塞进程</li>
<li>signal： 资源数 +1 ，如果 &lt;=0，那么还有进程在阻塞，唤醒队头进入就绪队列</li>
</ul>
</li>
<li><p>同步 by 信号量</p>
<ul>
<li>信号量设为0</li>
<li>「一前一后」 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220705013052706.png" srcset="/img/loading.gif" lazyload alt="image-20220705013052706" style="zoom: 50%;" /> 前操作后执行V，后操作之前执行P</li>
</ul>
</li>
<li><p>互斥 by 信号量</p>
<ul>
<li><code>semaphore mutex=1;</code>，要会自己定义。不是整型，是一个结构体</li>
<li>不同临界区/资源，设置不同的信号量</li>
</ul>
</li>
</ul>
<h4 id="2-3-3-经典问题"><a href="#2-3-3-经典问题" class="headerlink" title="2.3.3.经典问题"></a>2.3.3.经典问题</h4><ul>
<li>生产者-消费者<ul>
<li>两对同步：缓冲区没满 -&gt; 生产者生产；缓冲区没空 -&gt; 消费者消费</li>
<li>缓冲区是临界区资源，各进程互斥地访问</li>
<li>两个P操作顺序不能反，否则会死锁；V操作不会导致阻塞，所以顺序无所谓</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><pre><code class="hljs c++">semaphore mutex = <span class="hljs-number">1</span>;  <span class="hljs-comment">//互斥信号量，实现对缓冲区的互斥访问</span><br>semaphore empty = n;  <span class="hljs-comment">//同步信号量，表示空闲缓冲区的数量</span><br>semaphore full = <span class="hljs-number">0</span>;   <span class="hljs-comment">//同步信号量，表示产品的数量，也即非空缓冲区的数量</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">producer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//*********生产产品</span><br>        <span class="hljs-built_in">p</span>(empty);<br>        <span class="hljs-built_in">p</span>(mutex);<span class="hljs-comment">//*********加锁</span><br>        <span class="hljs-comment">//产品放入缓冲区</span><br>        <span class="hljs-built_in">v</span>(mutex);<span class="hljs-comment">//*********加锁</span><br>        <span class="hljs-built_in">v</span>(full);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">consumer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">p</span>(full);<br>        <span class="hljs-built_in">p</span>(mutex);<span class="hljs-comment">//*********加锁</span><br>        <span class="hljs-comment">//取出产品</span><br>        <span class="hljs-built_in">v</span>(mutex);<span class="hljs-comment">//*********加锁</span><br>        <span class="hljs-built_in">v</span>(empty);<br>        <span class="hljs-comment">//*********使用产品</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>多生产者-多消费者 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220705140133827.png" srcset="/img/loading.gif" lazyload alt="image-20220705140133827" style="zoom:50%;" /></p>
<blockquote>
<p>不是多个，而是多类</p>
<p>缓冲区大小为1时不用互斥加锁，因为同一时刻最多只有一个进程不被阻塞</p>
<p>不要从进程前后的角度来考虑同步关系，要从状态模型考虑同步关系</p>
</blockquote>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++">semaphore mutex = <span class="hljs-number">1</span>;  <span class="hljs-comment">//实现互斥访问盘子（缓冲区）</span><br>semaphore apple = <span class="hljs-number">0</span>;  <span class="hljs-comment">//盘子中有几个苹果</span><br>semaphore orange = <span class="hljs-number">0</span>; <span class="hljs-comment">//盘子中有几个橘子</span><br>semaphore plate = <span class="hljs-number">1</span>;  <span class="hljs-comment">//盘子中还可以放多少个水果</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dad</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//准备苹果</span><br>        <span class="hljs-built_in">p</span>(plate);<br>        <span class="hljs-built_in">p</span>(mutex);<br>        <span class="hljs-comment">//把苹果放进盘子</span><br>        <span class="hljs-built_in">v</span>(mutex);<br>        <span class="hljs-built_in">v</span>(apple);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">mom</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-comment">//准备橘子</span><br>        <span class="hljs-built_in">p</span>(plate);<br>        <span class="hljs-built_in">p</span>(mutex);<br>        <span class="hljs-comment">//把橘子放进盘子</span><br>        <span class="hljs-built_in">v</span>(mutex);<br>        <span class="hljs-built_in">v</span>(apple);<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">daughter</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">p</span>(apple);<br>        <span class="hljs-built_in">p</span>(mutex);<br>        <span class="hljs-comment">//取出苹果</span><br>        <span class="hljs-built_in">v</span>(mutex);<br>        <span class="hljs-built_in">v</span>(plate);<br>        <span class="hljs-comment">//吃掉苹果</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">son</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">p</span>(orange);<br>        <span class="hljs-built_in">p</span>(mutex);<br>        <span class="hljs-comment">//取出橘子</span><br>        <span class="hljs-built_in">v</span>(mutex);<br>        <span class="hljs-built_in">v</span>(plate);<br>        <span class="hljs-comment">//吃掉橘子</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><p>抽烟者问题 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220705143409645.png" srcset="/img/loading.gif" lazyload alt="image-20220705143409645" style="zoom: 40%;" /></p>
<ul>
<li>代码 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220705143702378.png" srcset="/img/loading.gif" lazyload alt="image-20220705143702378" style="zoom:50%;" /></li>
</ul>
</li>
<li><p>读者-写者问题</p>
<blockquote>
<p>允许多读1写</p>
<p>在写时其他进程不能进入</p>
<p>写之前其他进程必须全部退出</p>
</blockquote>
<ul>
<li>如果一直有进程在读，那写进程会饿死。因此增加了写优先信号量</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++">semaphore rw=<span class="hljs-number">1</span>;     <span class="hljs-comment">//用于实现对共享文件的互斥访问</span><br><span class="hljs-type">int</span> count <span class="hljs-number">0</span>;        <span class="hljs-comment">//记录当前有几个读进程在访问文件</span><br>semaphore mutex =<span class="hljs-number">1</span>；<span class="hljs-comment">//用于保证对count变量的互斥访问</span><br>semaphore w =<span class="hljs-number">1</span>;     <span class="hljs-comment">//用于实现“写优先”</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">writer</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">p</span>(w);<span class="hljs-comment">//*********为了写优先</span><br>        <span class="hljs-built_in">p</span>(rw);<br>        <span class="hljs-comment">//写文件</span><br>        <span class="hljs-built_in">v</span>(rw);<br>        <span class="hljs-built_in">v</span>(w);<span class="hljs-comment">//*********为了写优先</span><br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reader</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-built_in">p</span>(w);<span class="hljs-comment">//*********为了写优先</span><br>        <span class="hljs-built_in">p</span>(mutex);<br>        <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) <span class="hljs-built_in">p</span>(rw); count++;<br>        <span class="hljs-built_in">v</span>(mutex);<br>        <span class="hljs-built_in">v</span>(w);<span class="hljs-comment">//*********为了写优先</span><br>        <span class="hljs-comment">//读文件</span><br>        <span class="hljs-built_in">p</span>(mutex);<br>        count--; <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>) <span class="hljs-built_in">v</span>(rw);<br>        <span class="hljs-built_in">v</span>(mutex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>哲学家进餐问题<ul>
<li>思路1：限制同时进餐人数是总人数-1</li>
<li>思路2：奇数号先拿左边，偶数号先拿右边</li>
<li>思路3：检查完左右都可以使用后才拿起筷子</li>
</ul>
</li>
</ul>
<h4 id="2-3-4-管程"><a href="#2-3-4-管程" class="headerlink" title="2.3.4.管程"></a>2.3.4.管程</h4><p>线程安全的数据结构库</p>
<ul>
<li>组成部分<ul>
<li>局部于管程的<strong>共享数据结构</strong>说明</li>
<li>对该数据结构进行操作的<strong>一组过程</strong></li>
<li>对局部于管程的共享数据设置初始值的语句</li>
<li>管程有一个名字</li>
</ul>
</li>
<li>特征<ul>
<li>局部于管程的数据只能被局部于管程的过程所访问</li>
<li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据</li>
<li>每次仅允许一个进程在管程内执行某个内部过程</li>
</ul>
</li>
</ul>
<h3 id="2-4-死锁"><a href="#2-4-死锁" class="headerlink" title="2.4.死锁"></a>2.4.死锁</h3><ul>
<li><p>产生条件：互斥、不可剥夺、请求和保持、循环等待</p>
<blockquote>
<p>死锁一定循环等待，但是循环等待不一定死锁。循环等待是死锁的<strong>必要不充分</strong>条件</p>
</blockquote>
</li>
<li><p>发生时机</p>
<ul>
<li>系统资源竞争，如打印机</li>
<li>进程推进顺序非法，请求和释放资源顺序不当</li>
<li>信号量的使用不当</li>
</ul>
</li>
<li><p>处理策略</p>
<ul>
<li><p>预防死锁，破坏必要条件</p>
<ul>
<li><p>破坏-互斥：<strong>SPOOLing技术</strong>，将设备逻辑上抽象改造为共享设备</p>
<blockquote>
<p>适用范围不广</p>
</blockquote>
</li>
<li><p>破坏-不剥夺：</p>
<ul>
<li><p>资源不满足时<strong>立即释放</strong>，以后需要时重新申请</p>
<blockquote>
<p>一直如此的话会进程饥饿</p>
</blockquote>
</li>
<li><p>操作系统<strong>强行剥夺</strong>。需要考虑优先级</p>
<blockquote>
<p>实现复杂</p>
<p>剥夺之前的一部分工作会失效，只适用于易保存和恢复状态的资源，如CPU</p>
<p>反复申请资源增加开销</p>
</blockquote>
</li>
</ul>
</li>
<li><p>破坏-请求和保持：<strong>静态分配</strong>，运行之前一次性申请全部资源。资源未满足不会投入运行</p>
<blockquote>
<p>资源利用率极低，可能导致饥饿</p>
</blockquote>
</li>
<li><p>破坏-循环等待：<strong>顺序资源分配</strong>，给系统中的资源编号，每个进程必须按编号递增的顺序请求资源，同类资源（即编号相同的资源）一次申请完</p>
<blockquote>
<p>不方便增加新设备，可能所有资源都需要重新编号</p>
<p>实际使用资源顺序可能不是按照编号来，会浪费资源</p>
<p>必须按规定次序申请，用户编程麻烦</p>
</blockquote>
</li>
</ul>
</li>
<li><p>避免死锁，防止进入不安全状态</p>
<ul>
<li>安全序列：所有进程都能得到满足顺利结束</li>
<li>不安全状态：找不到一个安全序列，有可能死锁，除非有进程提前归还资源</li>
<li>银行家算法：<ul>
<li><u>扫描所有进程，找能运行的，认为其已经运行完，回收资源，重新扫描，直到所有进程都完成</u></li>
<li>检查此次申请是否超过了之前声明的最大需求数</li>
<li>检查此时系统剩余的可用资源是否还能满足这次请求</li>
<li>试探着分配，更改各数据结构</li>
<li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li>
</ul>
</li>
</ul>
</li>
<li><p>死锁的检测和解除</p>
<ul>
<li>检测<ul>
<li>不能消除所有边就是发生了死锁 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220705193654256.png" srcset="/img/loading.gif" lazyload alt="image-20220705193654256" style="zoom:40%;" /></li>
<li>找一个既不阻塞也不是孤点的点，将其所有边消去称为孤点</li>
</ul>
</li>
<li>解除<ul>
<li>挂起死锁进程，抢占资源。应注意防止饥饿</li>
<li>终止部分(或全部)死锁进程。实现简单，但代价大</li>
<li>一个或多个死锁进程回退到足以避免死锁的地步。需要记录历史信息、设置还原点</li>
</ul>
</li>
<li>如何决定对谁动手<ul>
<li>进程优先级</li>
<li>已执行多长时间</li>
<li>还要多久能完成</li>
<li>进程已经使用了多少资源</li>
<li>进程是交互式的还是批处理式的</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-内存"><a href="#3-内存" class="headerlink" title="3.内存"></a>3.内存</h2><h3 id="3-1-地址转换"><a href="#3-1-地址转换" class="headerlink" title="3.1.地址转换"></a>3.1.地址转换</h3><ul>
<li><p>装入的方式</p>
<ul>
<li><p>绝对装入：编译时就把变量地址修改为正确的地址</p>
<blockquote>
<p>灵活性很差，只适用于单道程序</p>
</blockquote>
</li>
<li><p>可重定位装入：<strong>装入内存时</strong>按照起始地址修改所有变量的地址</p>
<blockquote>
<p>需要空间分配连续，且作业一次全部装入内存</p>
<p>程序运行期间不可以移动</p>
</blockquote>
</li>
<li><p>动态运行时装入：程序真的要执行时才做地址转换</p>
<blockquote>
<p>现代操作系统 使用</p>
<p>需要<strong>重定位寄存器</strong>记录装入程序的起始地址</p>
</blockquote>
</li>
</ul>
</li>
<li><p>链接的方式</p>
<ul>
<li>静态链接：在程序运行之前，先将各目标模块及它们所需的库函数连接成一个完整的可执行文件（装入模块），之后不再拆开</li>
<li>装入时动态链接：将各目标模块装入内存时，边装入边链接的链接方式</li>
<li>运行时动态链接：在程序执行中需要该目标模块时，才对它进行链接。其优点是便于修改和更新，便于实现对目标模块的共享</li>
</ul>
</li>
</ul>
<h3 id="3-2-存储保护"><a href="#3-2-存储保护" class="headerlink" title="3.2.存储保护"></a>3.2.存储保护</h3><ul>
<li>设置上下限寄存器</li>
<li>利用重定位寄存器、界地址寄存器进行判断</li>
</ul>
<h3 id="3-3-内存空间扩充"><a href="#3-3-内存空间扩充" class="headerlink" title="3.3.内存空间扩充"></a>3.3.内存空间扩充</h3><ul>
<li><p>覆盖技术</p>
<blockquote>
<p>必须由程序员声明覆盖结构</p>
<p>对用户不透明，增加了用户编程负担</p>
</blockquote>
<ul>
<li>需要常驻内存的段放在“<strong>固定区</strong>”中，<strong>调入后就不再调出</strong>（除非运行结束）</li>
<li>不常用的段放在“<strong>覆盖区</strong>”，需要用到时调入内存，用不到时调出内存</li>
</ul>
</li>
<li><p>交换技术：进程在磁盘和内存之间动态调度。<strong>挂起状态</strong></p>
<blockquote>
<p>不是换出所有数据。PCB会常驻内存</p>
</blockquote>
<ul>
<li>什么位置：磁盘分为对换区和文件区，对换区为了速度选择<strong>连续分配</strong>，文件区为了利用率选择<strong>离散分配</strong></li>
<li>什么时候：经常发生缺页，说明内存紧张；缺页率下降可暂停换出</li>
<li>换出什么：优先级低、阻塞。为防止调入内存后很快换出，还会考虑<strong>内存驻留时间</strong></li>
</ul>
</li>
</ul>
<h3 id="3-4-空间分配"><a href="#3-4-空间分配" class="headerlink" title="3.4.空间分配"></a>3.4.空间分配</h3><h4 id="3-4-1-连续分配"><a href="#3-4-1-连续分配" class="headerlink" title="3.4.1.连续分配"></a>3.4.1.连续分配</h4><ul>
<li><p>单一连续分配</p>
<blockquote>
<p>内存当中同一时刻只能有一道用户程序，不支持多道程序并发运行，用户程序独占整个用户区</p>
<p>产生内部碎片</p>
</blockquote>
<ul>
<li>实现简单，无外部碎片</li>
<li>可以采用覆盖技术扩充内存</li>
<li><p>不(一定)需要内存保护</p>
</li>
<li><p>固定分区分配</p>
<ul>
<li><p>分区大小相等</p>
<blockquote>
<p>缺乏灵活性，适合用一台计算机控制n个相同的对象</p>
</blockquote>
</li>
<li><p>分区大小不等</p>
<ul>
<li>根据作业大小进行划分，如多个小分区，少量大分区</li>
</ul>
</li>
<li><p>分区说明表：包含 大小、起始地址、状态</p>
<blockquote>
<p>无外部碎片，有内部碎片（即有的分区不能完全使用，分配给程序却没有利用到）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>动态分区分配：在进程装入内存的时候，根据进程的大小动态地建立分区</p>
<blockquote>
<p>无内部碎片，有外部碎片（空闲区域太小，没有进程能用）</p>
</blockquote>
<ul>
<li><p>用什么记录：空闲分区表 或 空闲分区链</p>
</li>
<li><p><strong>紧凑技术</strong>：把进程挪位置，空出更大的连续空闲空间</p>
</li>
<li><p>分配算法</p>
<ul>
<li><p>首次适应：空闲分区以<strong>地址递增</strong>排列，选择第一个能满足的空闲分区（地址最小）</p>
</li>
<li><p>最佳适应：空闲分区以<strong>容量递增</strong>排列，选择第一个能满足的空闲分区（容量最小）</p>
<blockquote>
<p>留下很多难以利用的小碎片</p>
</blockquote>
</li>
<li><p>最坏适应：空闲分区以<strong>容量递减</strong>排列，选择第一个能满足的空闲分区（容量最大）</p>
<blockquote>
<p>大进程无处安放</p>
</blockquote>
</li>
<li><p>邻近适应：首次适应，但每次都从上一次查找结束的位置开始往后检索</p>
<ul>
<li>使用循环链表</li>
<li>算法开销小，不需要额外花时间重新排列</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-4-2-非连续分配"><a href="#3-4-2-非连续分配" class="headerlink" title="3.4.2.非连续分配"></a>3.4.2.非连续分配</h4><ul>
<li><p>基本分页存储管理：内粗分为大小相等的分区（4KB），进程的逻辑地址空间也分，进程页面与内存页框一一对应</p>
<ul>
<li><p>概念辨析</p>
<ul>
<li><strong>页、页面</strong>：进程的逻辑划分部分</li>
<li><strong>页框、页帧</strong>：内存的物理划分部分，又称为物理页面</li>
<li><strong>页表长度</strong>：页表总项数（如4G）</li>
<li><strong>页表项长度</strong>：每个页表项占多大空间（如3B）</li>
<li><strong>页面大小</strong>：一个页面多大（如4K）</li>
<li><strong>页目录表</strong>：更高层级的页表</li>
</ul>
</li>
<li><p>每个进程一个页表，一般放在PCB中。页面占$2^{12}$B，所以共有$2^{20}$块，至少需要3B来表示块号。块号连续存放所以不需要存储页号，已经隐含了</p>
</li>
<li><p>流程：拆分页号、偏移量；<strong>越界检查($\ge$)</strong>；[扫描快表]；查找内存块号；计算物理地址</p>
</li>
<li><p>为了方便页表的查询，经常会让一个页表项<strong>占更多的字节</strong>，使得每个页面恰好可以装得下整数个页表项</p>
<blockquote>
<p>例1：使用基本分页存储管理，采用了快表。访问一次快表耗时1us，访问一次内存耗时100us。若快表的命中率为90%，那么访问一个逻辑地址的平均耗时是多少？<strong>（此处快表慢表不同时查询）</strong></p>
<p>$(1+100)\times 0.9+(1+100+100)\times 0.1=111$us</p>
<p>例2：<img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708095847201.png" srcset="/img/loading.gif" lazyload alt="image-20220708095847201" style="zoom:100%;" /></p>
</blockquote>
</li>
</ul>
</li>
<li><p>基本分段存储管理</p>
<ul>
<li><p>段表：段号、段长、基址（段在内存中的起始位置）。16+32=48位即可，6字节</p>
</li>
<li><p>需要检查<strong>段内地址是否大于</strong>此段的<strong>段长</strong></p>
</li>
<li><p>更容易实现信息的共享和保护</p>
</li>
<li><p>只有纯代码（不可重入代码、不能被修改的代码）可以被共享的访问。那这种代码不属于临界资源，各个进程即使并发的访问这些代码也不会因为并发产生问题</p>
<blockquote>
<p>分页分段对比：</p>
<ul>
<li>页是信息的物理单位。对用户不可见；段是信息的逻辑单位。分段对用户可见，用户编程时需要显式地给出段名</li>
<li>分页当中进程的地址空间是一维的，而分段的时候进程的地址空间是二维的</li>
</ul>
</blockquote>
</li>
</ul>
</li>
<li><p>段页式存储管理</p>
<ul>
<li>结构 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708102626448.png" srcset="/img/loading.gif" lazyload alt="image-20220708102626448" style="zoom:100%;" /></li>
<li>分段过程程序员可见，分页不可见</li>
<li>只要快表命中就不需要再访问段表和页表</li>
</ul>
</li>
</ul>
<h3 id="3-5-虚拟内存"><a href="#3-5-虚拟内存" class="headerlink" title="3.5.虚拟内存"></a>3.5.虚拟内存</h3><ul>
<li>传统方式缺点：一次性（无法运行或并发度下降）、驻留性（浪费资源）</li>
<li>虚拟内存技术建立在<strong>离散分配</strong>的内存管理方式基础之上</li>
<li>需要新增的功能<ul>
<li>请求调页：访问的信息不在内存时，操作系统将所需信息从外存调入内存，继续执行程序</li>
<li>页面置换：若内存空间不够，操作系统将内存中暂时用不到的信息换出到外存</li>
</ul>
</li>
</ul>
<h4 id="3-5-1-请求调页"><a href="#3-5-1-请求调页" class="headerlink" title="3.5.1.请求调页"></a>3.5.1.请求调页</h4><ul>
<li><p>页表新增四项 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708150345084.png" srcset="/img/loading.gif" lazyload alt="image-20220708150345084" style="zoom:110%;" /></p>
</li>
<li><p>缺页中断机构：内中断（故障）</p>
<blockquote>
<p>一条指令中可能多次缺页中断，比如 copy A to B</p>
<p>如果页面被换出了内存，快表中页表项也应当删除</p>
<p>访问了一个页面后要修改快表、修改访问位 [和修改位（写指令时）]</p>
<p>调入内存后修改页表和快表，再访问直接从快表找到</p>
<p>缺页中断之后未必发生页面置换，只有内存块已经都满了才需要页面置换</p>
<p> <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708151511014.png" srcset="/img/loading.gif" lazyload alt="image-20220708151511014" style="zoom:120%;" /></p>
</blockquote>
</li>
</ul>
<h4 id="3-5-2-页面置换"><a href="#3-5-2-页面置换" class="headerlink" title="3.5.2.页面置换"></a>3.5.2.页面置换</h4><ul>
<li><p>最佳置换（OPT）</p>
<ul>
<li>每次选<strong>择淘汰的页面</strong>将是<strong>以后永不使用</strong>，或者在<strong>最长时间内不再被访问</strong></li>
<li>无法实现</li>
</ul>
</li>
<li><p>先进先出置换（FFO）</p>
<blockquote>
<p><strong>Belady异常</strong>——当为进程分配的物理块数增大时，缺页次数不减反增的异常现象。</p>
</blockquote>
</li>
<li><p>最近最久未使用置换（LRU）</p>
<ul>
<li>从后往前检查找到最久没使用的 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708152745909.png" srcset="/img/loading.gif" lazyload alt="image-20220708152745909" style="zoom:110%;" /></li>
</ul>
</li>
<li><p>时钟置换算法（CLOCK）</p>
<ul>
<li><p>性能和开销较均衡</p>
</li>
<li><p><strong>最近未用</strong>算法（NRU，Not Recently Used）</p>
</li>
<li><p>为每个页面设置一个<strong>访问位</strong>，再将内存中的页面都通过链接指针链接成一个<strong>循环队列</strong>。当某页被访问时，其访问位置为1。当需要淘汰一个页面时，只需检查页的访问位。如果是0，就选择该页换出；如果是1，则将它置为0，暂不换出，继续检查下一个页面，若第一轮扫描中所有页面都是1，则将这些页面的访问位依次置为0后，再进行第二轮扫描</p>
<blockquote>
<p>第二轮扫描中一定会有访问位为0的页面，因此简单的CLOCK算法选择一个淘汰页面<strong>最多会经过两轮扫描</strong></p>
</blockquote>
</li>
</ul>
</li>
<li><p>改进型的时钟置换：优先淘汰<strong>未修改过</strong>的页面，减少IO次数</p>
<ul>
<li>第一轮：从当前位置开始扫描到第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位</li>
<li>第二轮：若第一轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换。本轮<strong>将所有扫描过的帧访问位设为0</strong></li>
<li>第三轮：若第二轮扫描失败，则重新扫描，查找第一个（0，0）的帧用于替换。本轮扫描不修改任何标志位</li>
<li>第四轮：若第三轮扫描失败，则重新扫描，查找第一个（0，1）的帧用于替换</li>
<li>最多4轮</li>
</ul>
</li>
</ul>
<h4 id="3-5-3-页面分配"><a href="#3-5-3-页面分配" class="headerlink" title="3.5.3.页面分配"></a>3.5.3.页面分配</h4><ul>
<li>驻留集：实际在内存中页面数量 / 总页面数量</li>
<li>页面分配策略<ul>
<li>固定分配：局部置换<ul>
<li>为每个进程分配一组固定数目的物理块</li>
<li>很难在刚开始的时候就确定应该为每个进程分配多少个物理块才能才算合适</li>
</ul>
</li>
<li>可变分配：局部置换（<strong>取决于缺页频率</strong>）、全局置换（打土豪分田地，<strong>只要缺页必定分配</strong>）<ul>
<li>进程运行期间，可根据情况做适当的增加或减少</li>
</ul>
</li>
<li>预调页：主要用于进程首次调入，由程序员指出哪些先调入</li>
<li>请求调页：运行中缺页时才调入。IO开销较大</li>
</ul>
</li>
<li>调入页面的时机<ul>
<li>对换区够大：调入调出都是对换区，因为快</li>
<li>对换区不够大：不会被修改的数据都直接从文件区调入，换出时不必写回磁盘，下次需要时再从文件区调入即可。可能被修改的部分换出时需写回磁盘对换区，下次需要时再从对换区调入</li>
<li>UNIX方式：运行之前进程有关的数据全部放在文件区，故未使用过的页面，都可从文件区调入。若被使用过的页面需要换出，则写回对换区，下次需要时从对换区调入</li>
</ul>
</li>
<li>抖动（颠簸）现象：频繁访问的块数目高于可用物理块数</li>
<li>工作集：在某段时间间隔里，进程实际访问页面的集合<ul>
<li>大小可以小窗口实际尺寸</li>
<li>一般来说驻留集不能小于工作集</li>
</ul>
</li>
</ul>
<h2 id="4-文件"><a href="#4-文件" class="headerlink" title="4.文件"></a>4.文件</h2><h3 id="4-1-逻辑结构"><a href="#4-1-逻辑结构" class="headerlink" title="4.1.逻辑结构"></a>4.1.逻辑结构</h3><ul>
<li><p>无结构文件</p>
</li>
<li><p>有结构文件</p>
<ul>
<li><p>顺序文件</p>
<blockquote>
<p>串结构：记录之间的顺序与关键字无关</p>
<p>顺序结构：记录之间的顺序按关键字顺序排列</p>
</blockquote>
<ul>
<li>随机存取 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220708225322327.png" srcset="/img/loading.gif" lazyload alt="image-20220708225322327" style="zoom:120%;" /></li>
</ul>
</li>
<li><p>索引文件：本身是<strong>定长记录的顺序文件</strong></p>
<ul>
<li>用于对信息处理的及时性要求比较高的场合</li>
<li>若索引表按关键字顺序排列，则可支持快速检索</li>
</ul>
</li>
<li><p>索引顺序文件：对记录进行分组，每一个分组建立一个索引表项</p>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-文件功能"><a href="#4-2-文件功能" class="headerlink" title="4.2.文件功能"></a>4.2.文件功能</h3><ul>
<li><p>目录</p>
<ul>
<li>单级目录不能重名；两级目录不同用户的文件可以重名，但是文件不能分类</li>
<li><p>FCB的有序集合称为“文件目录”，一个FCB就是一个文件目录项。 FCB中包含了文件的基本信息（文件名、物理地址、逻辑结构、物理结构等），存取控制信息（是否可读/可写、禁止访问的用户名单等），使用信息（如文件的建立时间、修改时间等）</p>
</li>
<li><p><strong>树形目录结构</strong>可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。但是，树形结构<strong>不便于实现文件的共享</strong>。为此，提出了“<strong>无环图目录结构</strong>”——多个用户的文件指向同一个文件，使用共享计数器</p>
</li>
<li><p>FCB改进：文件名+索引节点指针。把所有其他信息都放到索引节点中</p>
</li>
<li><p>内存索引节点需要增加是否被修改、有多少个进程访问等信息</p>
</li>
</ul>
</li>
<li><p>保护</p>
<ul>
<li><p>口令：时间和空间的开销都小，但是口令保存在系统内部，如果泄露就畅通无阻了</p>
</li>
<li><p>加密：保密性强、不需要保存密码，但加密解密耗时</p>
</li>
<li><p>访问控制</p>
<blockquote>
<p>ACL表内容：<img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220710143640788.png" srcset="/img/loading.gif" lazyload alt="image-20220710143640788" style="zoom:50%;" /> 不重要，了解即可</p>
<p>如果对某个目录进行了访问权限的控制，那也要对目录下的所有文件进行相同的访问权限控制</p>
</blockquote>
</li>
</ul>
</li>
<li><p>共享</p>
<ul>
<li>索引节点：硬链接：多个索引节点指针指向同一个索引节点</li>
<li>符号链：软链接：一个特殊的Link类型文件，记录实际指向文件的绝对路径<ul>
<li>文件实际删除不影响软链接，只是链接失效</li>
<li>速度比硬连接慢</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-物理结构"><a href="#4-3-物理结构" class="headerlink" title="4.3.物理结构"></a>4.3.物理结构</h3><h4 id="4-3-1-非空闲块"><a href="#4-3-1-非空闲块" class="headerlink" title="4.3.1.非空闲块"></a>4.3.1.非空闲块</h4><p>通常块和内存页面一样大，也 是用逻辑块号+块内地址这种方式 </p>
<ul>
<li><p>连续分配 </p>
<ul>
<li><p>支持<strong>顺序访问</strong>和<strong>直接访问</strong></p>
</li>
<li><p>读写速度最快</p>
<blockquote>
<p>增加内容需要整体迁移文件</p>
<p>碎片无法利用，可能无法找到足够大的连续空间</p>
</blockquote>
</li>
</ul>
</li>
<li><p>链接分配</p>
<blockquote>
<p>没说是哪种链接分配默认是<strong>隐式链接</strong></p>
</blockquote>
<ul>
<li>隐式链接：每一块中存储指向下一块的指针，对用户透明<ul>
<li>支持<strong>顺序访问</strong>，不支持随机访问</li>
<li>文件拓展方便，不会有碎片，空间利用率高</li>
</ul>
</li>
<li>显式链接：各个块的指针显式地存放在<strong>文件分配表(FAT)</strong>中 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220710161813080.png" srcset="/img/loading.gif" lazyload alt="image-20220710161813080" style="zoom:40%;" /><ul>
<li>一个文件只需要一张表，常驻内存</li>
<li>支持随机访问</li>
<li>地址转换过程不需要访问磁盘，文件访问效率高</li>
</ul>
</li>
</ul>
</li>
<li><p>索引分配：为每个文件建立一张索引表，文件名关联索引表的存放位置 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220710190653753.png" srcset="/img/loading.gif" lazyload alt="image-20220710190653753" style="zoom:50%;" /></p>
<ul>
<li><p>二级索引</p>
<blockquote>
<p>例题：假设磁盘块大小为1KB，一个索引表项占4B，则一个磁盘块只能存放256个索引项。<br>若某文件采用两层索引，则该文件的最大长度可以到256 <em> 256 </em> 1KB = 65,536KB = 64MB</p>
</blockquote>
</li>
<li><p>混合索引 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220710193018586.png" srcset="/img/loading.gif" lazyload alt="image-20220710193018586" style="zoom:40%;" /></p>
</li>
</ul>
</li>
<li><p>逻辑结构 和 物理结构 概念辨析</p>
<blockquote>
<p>链式存储是用户自己选择的数据逻辑结构；链式分配是操作系统自动完成的链式分配空间，对用户透明</p>
<p>索引文件和索引分配 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220711144249529.png" srcset="/img/loading.gif" lazyload alt="image-20220711144249529" style="zoom:60%;" /></p>
</blockquote>
</li>
</ul>
<h4 id="4-3-2-空闲块"><a href="#4-3-2-空闲块" class="headerlink" title="4.3.2.空闲块"></a>4.3.2.空闲块</h4><ul>
<li>几种管理方法<ul>
<li>空闲表法：每一个空闲区间的起始位置和长度</li>
<li>空闲链表法<ul>
<li>空闲盘块链</li>
<li>空闲盘区链：连续空闲区间之间组成一条链</li>
</ul>
</li>
<li>位示图法<ul>
<li>盘块号转换字号位号，注意是否从0开始</li>
</ul>
</li>
<li>成组链接法<ul>
<li>超级块常驻内存，与磁盘同步 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220711160920617.png" srcset="/img/loading.gif" lazyload alt="image-20220711160920617" style="zoom:35%;" /></li>
<li>如果有一个分组全部分配出去，需要把指向下一块的链接信息复制到超级块中</li>
<li>回收块时如果第一个分组已经满了，需要新建一个块，指向第一个分组（类似于头插）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-4-基本操作"><a href="#4-4-基本操作" class="headerlink" title="4.4.基本操作"></a>4.4.基本操作</h3><ul>
<li>创建：找到空间、创建文件对应目录项</li>
<li>删除：找到目录项、回收磁盘块</li>
<li>打开：找到目录项并查看权限、将目录项复制到内存中的“打开文件表”中、用户使用打开文件表的编号（<strong>文件描述符</strong>）来指明要操作的文件<ul>
<li>系统的打开文件表，整个系统只有一张，记录所有的正在被其他进程使用的文件的一些信息</li>
<li>进程的打开文件表，记录了自己的这个进程此时打开了哪些文件</li>
<li>示意图 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220712014849661.png" srcset="/img/loading.gif" lazyload alt="image-20220712014849661" style="zoom:50%;" /></li>
</ul>
</li>
<li>关闭：删除进程打开文件表中的表项、修改打开计数器。按情况回收资源</li>
<li>读：指明打开文件的编号（已经打开过了）、读入多少、放在内存什么位置</li>
</ul>
<h3 id="4-5-文件系统层次结构"><a href="#4-5-文件系统层次结构" class="headerlink" title="4.5.文件系统层次结构"></a>4.5.文件系统层次结构</h3><ul>
<li>示意图 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220712015829973.png" srcset="/img/loading.gif" lazyload alt="image-20220712015829973" style="zoom:50%;" /></li>
</ul>
<h3 id="4-6-磁盘"><a href="#4-6-磁盘" class="headerlink" title="4.6.磁盘"></a>4.6.磁盘</h3><p>块号：柱面号、盘面号、扇区号</p>
<p>固定头磁盘（每个磁道有一个磁头）</p>
<p>移动头磁盘（每个盘面只有一个磁头）</p>
<ul>
<li><p>一次读写时间</p>
<ul>
<li><p>寻找时间：启动磁头臂+移动磁头</p>
<blockquote>
<p>启动 + 移动个数 * 每个时间</p>
</blockquote>
</li>
<li><p>延迟时间：旋转磁盘的时间</p>
<blockquote>
<p>转半圈的时间</p>
</blockquote>
</li>
<li><p>传输时间</p>
<blockquote>
<p>转一圈的时间 * 需要转多少圈</p>
</blockquote>
</li>
</ul>
</li>
<li><p>调度算法</p>
<blockquote>
<p>没有特殊说明，默认不是走到头那种算法</p>
</blockquote>
<ul>
<li>先来先服务（FCFS）：大量分布较广的请求性能不好</li>
<li>最短寻找时间优先（SSTF）：性能较好，<strong>可能饥饿</strong></li>
<li>扫描算法(SCAN)：移动到<strong>最外侧磁道（不是最大的请求，是边界）</strong>才能反向<ul>
<li>LOOK调度算法：到最边上一个请求后立即反向</li>
</ul>
</li>
<li>循环扫描算法（C-SCAN）<ul>
<li>移动到<strong>最外侧磁道（不是最大的请求，是边界）</strong>才能反向</li>
<li>立即回到起始位置，不做任何处理</li>
<li>C-LOOK：两边都是最远请求就停止，不用到头</li>
</ul>
</li>
</ul>
</li>
<li><p>优化方法</p>
<ul>
<li>交替编号：让逻辑上相邻的扇区在物理上有一定的间隔</li>
<li>柱面号在盘面号之前：读取连续磁盘块时，减少磁头移动消耗的时间</li>
<li>错位命名：上下盘片之间磁道命名错开</li>
</ul>
</li>
<li><p>磁盘初始化</p>
<ul>
<li>低级格式化，划分扇区。头、数据区域（如512B大小）、尾三个部分组成。管理扇区所需要的各种数据结构一般存放在头、尾两个部分，包括扇区校验码（如奇偶校验、CC循环冗余校验码等，校验码用于校验扇区中的数据是否发生错误）</li>
<li>分区，每个分区由若干柱面组成 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220712231307737.png" srcset="/img/loading.gif" lazyload alt="image-20220712231307737" style="zoom:40%;" /></li>
<li>逻辑格式化，创建文件系统。创建文件系统的根目录、初始化存储空间管理所用的数据结构（如位示图、空闲分区表）</li>
</ul>
</li>
<li><p>引导块</p>
<ul>
<li>ROM中只存放很小的「自举装入程序」，完整的自举程序放在磁盘的启动块（即引导块/启动分区）上，启动块位于磁盘的固定位置</li>
<li>拥有引导块的逻辑磁盘就是系统盘</li>
</ul>
</li>
<li><p>坏块管理</p>
<ul>
<li>在FAT表中标记。对系统不透明</li>
<li>扇区备用：磁盘控制器维护坏块链表，低格时对其初始化。同时会保留一些备用扇区用于替换坏块。对系统透明</li>
</ul>
</li>
</ul>
<h2 id="6-设备"><a href="#6-设备" class="headerlink" title="6.设备"></a>6.设备</h2><h3 id="6-1-分类"><a href="#6-1-分类" class="headerlink" title="6.1.分类"></a>6.1.分类</h3><ul>
<li><p>按使用特性</p>
<ul>
<li>人机交互</li>
<li>存储设备</li>
<li>网络通信设备</li>
</ul>
</li>
<li><p>按传输速率</p>
<ul>
<li>低速：鼠标键盘</li>
<li>中速：激光打印机</li>
<li>高速：硬盘</li>
</ul>
</li>
<li><p>按信息交换单位</p>
<ul>
<li><p>块设备：磁盘</p>
<blockquote>
<p>传输速率较高，可寻址，即对它可随机地读/写任一块</p>
</blockquote>
</li>
<li><p>字符设备：鼠标键盘</p>
<blockquote>
<p>传输速率较慢，不可寻址，在输入/输出时常采用中断驱动方式</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="6-2-IO控制"><a href="#6-2-IO控制" class="headerlink" title="6.2.IO控制"></a>6.2.IO控制</h3><ul>
<li><p>IO控制器 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220713065355694.png" srcset="/img/loading.gif" lazyload alt="image-20220713065355694" style="zoom:50%;" /></p>
<ul>
<li>接受和识别CPU发出的命令（控制寄存器）</li>
<li>向CPU报告设备的状态（状态寄存器）</li>
<li>数据交换（数据寄存器）</li>
<li>地址识别</li>
</ul>
</li>
<li><p>编址方式</p>
<ul>
<li>内存映象</li>
<li>寄存器独立编址：需要设置专门的指令来进行操作</li>
</ul>
</li>
<li><p>控制方式</p>
<ul>
<li><p>程序直接控制</p>
<blockquote>
<p>CPU干预频率：很频繁</p>
<p>数据传送单位：一个字</p>
<p>数据流向：内存和IO设备之间一定要经过CPU</p>
</blockquote>
</li>
<li><p>中断驱动</p>
<blockquote>
<p>CPU干预频率：等待IO过程中CPU可以干别的，<strong>实现了CPU和IO并行</strong></p>
<p>数据传送单位：一个字</p>
<p>数据流向：内存和IO设备之间一定要经过CPU</p>
</blockquote>
</li>
<li><p>DMA（直接存储器存取）<img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220713071726194.png" srcset="/img/loading.gif" lazyload alt="image-20220713071726194" style="zoom:40%;" /></p>
<blockquote>
<p>CPU干预频率： 请在一块数据的开始和结束时需要CPU的干预</p>
<p>数据传送单位：一个字 或 一个块（必须连续。不连续还是要多条指令）</p>
<p>数据流向：<strong>不需要经过CPU</strong></p>
</blockquote>
</li>
<li><p>通道控制</p>
<blockquote>
<p>CPU干预频率：很低，完成一系列读写才会有一次中断信号</p>
<p>数据传送单位：一组数据块 </p>
<p>数据流向：不需要经过CPU</p>
<p>一个通道可以控制多个 IO 控制器，而一个 IO 控制器又可以控制多个 IO 设备</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="6-3-IO核心子层"><a href="#6-3-IO核心子层" class="headerlink" title="6.3.IO核心子层"></a>6.3.IO核心子层</h3><ul>
<li><p>结构 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220713094119330.png" srcset="/img/loading.gif" lazyload alt="image-20220713094119330" style="zoom:50%;" /></p>
</li>
<li><p>SPOOLing技术：「输入/输出设备」和「输入/输出井」之间使用内存中的「输入/输出缓冲区」进行缓冲</p>
</li>
<li><p>设备分配</p>
<ul>
<li><p>安全分配：只要分配了IO设备就一定会阻塞。资源利用率低</p>
</li>
<li><p>不安全分配：进程不会被阻塞，继续往下执行。可能导致<strong>死锁</strong>，可以使用银行家算法</p>
</li>
<li><p>数据结构</p>
<ul>
<li><p>设备控制表DCT <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714092009949.png" srcset="/img/loading.gif" lazyload alt="image-20220714092009949" style="zoom:50%;" /></p>
</li>
<li><p>控制器控制表COCT <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714092212003.png" srcset="/img/loading.gif" lazyload alt="image-20220714092212003" style="zoom:50%;" /></p>
</li>
<li><p>通道控制表CHCT <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714092405728.png" srcset="/img/loading.gif" lazyload alt="image-20220714092405728" style="zoom:50%;" /></p>
</li>
<li><p>系统设备表（SDT）：记录了系统中<strong>全部设备</strong>的情况，每个设备对应一个表目</p>
<blockquote>
<p>缺点： </p>
<ul>
<li>用户编程时必须使用“物理设备名”，底层细节对用户不透明，不方便编程</li>
<li>若换了一个物理设备，则程序无法运行</li>
<li>若进程请求的物理设备正在忙碌，则即使系统中还有同类型的设备，进程也必须阻塞等待</li>
</ul>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
<li><p>设备分配的改进</p>
<ul>
<li><strong>逻辑设备表</strong>（LUT）建立了逻辑设备名与物理设备名之间的映射关系</li>
<li>第一次使用<strong>设备类型</strong>请求资源时，系统查询系统设备表，并在逻辑设备表中增加表项，下次请求时直接查逻辑设备表</li>
</ul>
</li>
</ul>
<h3 id="6-4-缓冲区管理"><a href="#6-4-缓冲区管理" class="headerlink" title="6.4.缓冲区管理"></a>6.4.缓冲区管理</h3><ul>
<li>作用<ul>
<li>缓和CPU与I/O设备之间速度不匹配的矛盾</li>
<li>减少对CPU的中断频率，放宽对CPU中断相应时间的限制</li>
<li>解决数据粒度不匹配的问题</li>
<li>提高CPU与I/O设备之间的并行性</li>
</ul>
</li>
<li><strong>缓冲区必须充满后才能取出数据</strong></li>
<li>周期 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714094211540.png" srcset="/img/loading.gif" lazyload alt="image-20220714094211540" style="zoom:45%;" /></li>
<li>单缓冲，T&gt;C时，T+M；T&lt;C时，C+M</li>
<li>双缓冲，Max(T,C+M )</li>
<li>循环缓冲区：将多个<strong>大小相等</strong>的缓冲区链接成一个<strong>循环队列</strong> <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714095441427.png" srcset="/img/loading.gif" lazyload alt="image-20220714095441427" style="zoom:50%;" /></li>
<li>缓冲池 <img src="https://typora-gilgamesh.oss-cn-shanghai.aliyuncs.com/img1/2022:07:14-10:01:07-image-20220714095658350.png" srcset="/img/loading.gif" lazyload alt="image-20220714095658350" style="zoom:50%;" /></li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E8%80%83%E7%A0%94/">考研</a>
                    
                  </div>
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外均为原创，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/blog/9dd8d2cc97df/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">制作视频外挂字幕</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/blog/a65539427ee0/">
                        <span class="hidden-mobile">让你的PDF更容易阅读</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
    

  </div>
  

  
  <!-- 备案信息 -->
  <div class="beian">
    <span>
      <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
        沪ICP证2022011890号
      </a>
    </span>
    
  </div>


  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js" ></script>
  
  
    <script defer src="https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js" ></script>
  






  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
        typing(title);
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
